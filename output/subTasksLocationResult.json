[
    {
        "subtask": "实现一个处理文件打开、关闭及错误情况的线程安全函数是什么？",
        "results": {
            "query": "实现一个处理文件打开、关闭及错误情况的线程安全函数是什么？",
            "results": [
                {
                    "similarity": 0.5809846770176494,
                    "meta_info": {
                        "category": "Function",
                        "code": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  sigset_t signewset;\n  int close_fd;\n  int use_fd;\n  int fd;\n  int n;\n\n  /* Reset signal disposition first. Use a hard-coded limit because NSIG is not\n   * fixed on Linux: it's either 32, 34 or 64, depending on whether RT signals\n   * are enabled. We are not allowed to touch RT signal handlers, glibc uses\n   * them internally.\n   */\n  for (n = 1; n < 32; n += 1) {\n    if (n == SIGKILL || n == SIGSTOP)\n      continue;  /* Can't be changed. */\n\n#if defined(__HAIKU__)\n    if (n == SIGKILLTHR)\n      continue;  /* Can't be changed. */\n#endif\n\n    if (SIG_ERR != signal(n, SIG_DFL))\n      continue;\n\n    uv__write_errno(error_fd);\n  }\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  /* First duplicate low numbered fds, since it's not safe to duplicate them,\n   * they could get replaced. Example: swapping stdout and stderr; without\n   * this fd 2 (stderr) would be duplicated into fd 1, thus making both\n   * stdout and stderr go to the same fd, which was not the intention. */\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n    if (use_fd < 0 || use_fd >= fd)\n      continue;\n#ifdef F_DUPFD_CLOEXEC /* POSIX 2008 */\n    pipes[fd][1] = fcntl(use_fd, F_DUPFD_CLOEXEC, stdio_count);\n#else\n    pipes[fd][1] = fcntl(use_fd, F_DUPFD, stdio_count);\n#endif\n    if (pipes[fd][1] == -1)\n      uv__write_errno(error_fd);\n#ifndef F_DUPFD_CLOEXEC /* POSIX 2008 */\n    n = uv__cloexec(pipes[fd][1], 1);\n    if (n)\n      uv__write_int(error_fd, n);\n#endif\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = -1;\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* Redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set. */\n        uv__close_nocheckstdio(fd); /* Free up fd, if it happens to be open. */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd < 0)\n          uv__write_errno(error_fd);\n      }\n    }\n\n    if (fd == use_fd) {\n      if (close_fd == -1) {\n        n = uv__cloexec(use_fd, 0);\n        if (n)\n          uv__write_int(error_fd, n);\n      }\n    }\n    else {\n      fd = dup2(use_fd, fd);\n    }\n\n    if (fd == -1)\n      uv__write_errno(error_fd);\n\n    if (fd <= 2 && close_fd == -1)\n      uv__nonblock_fcntl(fd, 0);\n\n    if (close_fd >= stdio_count)\n      uv__close(close_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd))\n    uv__write_errno(error_fd);\n\n  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n    /* When dropping privileges from root, the `setgroups` call will\n     * remove any extraneous groups. If we don't call this, then\n     * even though our uid has dropped, we may still have groups\n     * that enable us to do super-user things. This will fail if we\n     * aren't root, so don't bother checking the return value, this\n     * is just done as an optimistic privilege dropping function.\n     */\n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid))\n    uv__write_errno(error_fd);\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid))\n    uv__write_errno(error_fd);\n\n  if (options->env != NULL)\n    environ = options->env;\n\n  /* Reset signal mask just before exec. */\n  sigemptyset(&signewset);\n  if (sigprocmask(SIG_SETMASK, &signewset, NULL) != 0)\n    abort();\n\n#ifdef __MVS__\n  execvpe(options->file, options->args, environ);\n#else\n  execvp(options->file, options->args);\n#endif\n\n  uv__write_errno(error_fd);\n}\n"
                    }
                },
                {
                    "similarity": 0.5786482095718384,
                    "meta_info": {
                        "category": "Function",
                        "code": "int uv_pipe_open(uv_pipe_t* pipe, uv_file file) {\n  HANDLE os_handle = uv__get_osfhandle(file);\n  NTSTATUS nt_status;\n  IO_STATUS_BLOCK io_status;\n  FILE_ACCESS_INFORMATION access;\n  DWORD duplex_flags = 0;\n  int err;\n\n  if (os_handle == INVALID_HANDLE_VALUE)\n    return UV_EBADF;\n  if (pipe->flags & UV_HANDLE_PIPESERVER)\n    return UV_EINVAL;\n  if (pipe->flags & UV_HANDLE_CONNECTION)\n    return UV_EBUSY;\n\n  uv__pipe_connection_init(pipe);\n  uv__once_init();\n  /* In order to avoid closing a stdio file descriptor 0-2, duplicate the\n   * underlying OS handle and forget about the original fd.\n   * We could also opt to use the original OS handle and just never close it,\n   * but then there would be no reliable way to cancel pending read operations\n   * upon close.\n   */\n  if (file <= 2) {\n    if (!DuplicateHandle(INVALID_HANDLE_VALUE,\n                         os_handle,\n                         INVALID_HANDLE_VALUE,\n                         &os_handle,\n                         0,\n                         FALSE,\n                         DUPLICATE_SAME_ACCESS))\n      return uv_translate_sys_error(GetLastError());\n    assert(os_handle != INVALID_HANDLE_VALUE);\n    file = -1;\n  }\n\n  /* Determine what kind of permissions we have on this handle.\n   * Cygwin opens the pipe in message mode, but we can support it,\n   * just query the access flags and set the stream flags accordingly.\n   */\n  nt_status = pNtQueryInformationFile(os_handle,\n                                      &io_status,\n                                      &access,\n                                      sizeof(access),\n                                      FileAccessInformation);\n  if (nt_status != STATUS_SUCCESS)\n    return UV_EINVAL;\n\n  if (pipe->ipc) {\n    if (!(access.AccessFlags & FILE_WRITE_DATA) ||\n        !(access.AccessFlags & FILE_READ_DATA)) {\n      return UV_EINVAL;\n    }\n  }\n\n  if (access.AccessFlags & FILE_WRITE_DATA)\n    duplex_flags |= UV_HANDLE_WRITABLE;\n  if (access.AccessFlags & FILE_READ_DATA)\n    duplex_flags |= UV_HANDLE_READABLE;\n\n  err = uv__set_pipe_handle(pipe->loop,\n                            pipe,\n                            os_handle,\n                            file,\n                            duplex_flags);\n  if (err) {\n    if (file == -1)\n      CloseHandle(os_handle);\n    return err;\n  }\n\n  if (pipe->ipc) {\n    assert(!(pipe->flags & UV_HANDLE_NON_OVERLAPPED_PIPE));\n    GetNamedPipeClientProcessId(os_handle, &pipe->pipe.conn.ipc_remote_pid);\n    if (pipe->pipe.conn.ipc_remote_pid == GetCurrentProcessId()) {\n      GetNamedPipeServerProcessId(os_handle, &pipe->pipe.conn.ipc_remote_pid);\n    }\n    assert(pipe->pipe.conn.ipc_remote_pid != (DWORD)(uv_pid_t) -1);\n  }\n  return 0;\n}\n"
                    }
                },
                {
                    "similarity": 0.5715731382369995,
                    "meta_info": {
                        "category": "Function",
                        "code": "static int uv__process_open_stream(uv_stdio_container_t* container,\n                                   int pipefds[2]) {\n  int flags;\n  int err;\n\n  if (!(container->flags & UV_CREATE_PIPE) || pipefds[0] < 0)\n    return 0;\n\n  err = uv__close(pipefds[1]);\n  if (err != 0)\n    abort();\n\n  pipefds[1] = -1;\n  uv__nonblock(pipefds[0], 1);\n\n  flags = 0;\n  if (container->flags & UV_WRITABLE_PIPE)\n    flags |= UV_HANDLE_READABLE;\n  if (container->flags & UV_READABLE_PIPE)\n    flags |= UV_HANDLE_WRITABLE;\n\n  return uv__stream_open(container->data.stream, pipefds[0], flags);\n}\n"
                    }
                },
                {
                    "similarity": 0.5659105777740479,
                    "meta_info": {
                        "category": "Function",
                        "code": "FILE* uv__open_file(const char* path) {\n  int fd;\n  FILE* fp;\n\n  fd = uv__open_cloexec(path, O_RDONLY);\n  if (fd < 0)\n    return NULL;\n\n   fp = fdopen(fd, \"r\");\n   if (fp == NULL)\n     uv__close(fd);\n\n   return fp;\n}\n"
                    }
                },
                {
                    "similarity": 0.5649750828742981,
                    "meta_info": {
                        "category": "Function",
                        "code": "void fs__open(uv_fs_t* req) {\n  DWORD access;\n  DWORD share;\n  DWORD disposition;\n  DWORD attributes = 0;\n  HANDLE file;\n  int fd, current_umask;\n  int flags = req->fs.info.file_flags;\n  struct uv__fd_info_s fd_info;\n\n  /* Adjust flags to be compatible with the memory file mapping. Save the\n   * original flags to emulate the correct behavior. */\n  if (flags & UV_FS_O_FILEMAP) {\n    fd_info.flags = flags;\n    fd_info.current_pos.QuadPart = 0;\n\n    if ((flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR)) ==\n        UV_FS_O_WRONLY) {\n      /* CreateFileMapping always needs read access */\n      flags = (flags & ~UV_FS_O_WRONLY) | UV_FS_O_RDWR;\n    }\n\n    if (flags & UV_FS_O_APPEND) {\n      /* Clear the append flag and ensure RDRW mode */\n      flags &= ~UV_FS_O_APPEND;\n      flags &= ~(UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR);\n      flags |= UV_FS_O_RDWR;\n    }\n  }\n\n  /* Obtain the active umask. umask() never fails and returns the previous\n   * umask. */\n  current_umask = _umask(0);\n  _umask(current_umask);\n\n  /* convert flags and mode to CreateFile parameters */\n  switch (flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR)) {\n  case UV_FS_O_RDONLY:\n    access = FILE_GENERIC_READ;\n    break;\n  case UV_FS_O_WRONLY:\n    access = FILE_GENERIC_WRITE;\n    break;\n  case UV_FS_O_RDWR:\n    access = FILE_GENERIC_READ | FILE_GENERIC_WRITE;\n    break;\n  default:\n    goto einval;\n  }\n\n  if (flags & UV_FS_O_APPEND) {\n    access &= ~FILE_WRITE_DATA;\n    access |= FILE_APPEND_DATA;\n  }\n\n  /*\n   * Here is where we deviate significantly from what CRT's _open()\n   * does. We indiscriminately use all the sharing modes, to match\n   * UNIX semantics. In particular, this ensures that the file can\n   * be deleted even whilst it's open, fixing issue\n   * https://github.com/nodejs/node-v0.x-archive/issues/1449.\n   * We still support exclusive sharing mode, since it is necessary\n   * for opening raw block devices, otherwise Windows will prevent\n   * any attempt to write past the master boot record.\n   */\n  if (flags & UV_FS_O_EXLOCK) {\n    share = 0;\n  } else {\n    share = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;\n  }\n\n  switch (flags & (UV_FS_O_CREAT | UV_FS_O_EXCL | UV_FS_O_TRUNC)) {\n  case 0:\n  case UV_FS_O_EXCL:\n    disposition = OPEN_EXISTING;\n    break;\n  case UV_FS_O_CREAT:\n    disposition = OPEN_ALWAYS;\n    break;\n  case UV_FS_O_CREAT | UV_FS_O_EXCL:\n  case UV_FS_O_CREAT | UV_FS_O_TRUNC | UV_FS_O_EXCL:\n    disposition = CREATE_NEW;\n    break;\n  case UV_FS_O_TRUNC:\n  case UV_FS_O_TRUNC | UV_FS_O_EXCL:\n    disposition = TRUNCATE_EXISTING;\n    break;\n  case UV_FS_O_CREAT | UV_FS_O_TRUNC:\n    disposition = CREATE_ALWAYS;\n    break;\n  default:\n    goto einval;\n  }\n\n  attributes |= FILE_ATTRIBUTE_NORMAL;\n  if (flags & UV_FS_O_CREAT) {\n    if (!((req->fs.info.mode & ~current_umask) & _S_IWRITE)) {\n      attributes |= FILE_ATTRIBUTE_READONLY;\n    }\n  }\n\n  if (flags & UV_FS_O_TEMPORARY ) {\n    attributes |= FILE_FLAG_DELETE_ON_CLOSE | FILE_ATTRIBUTE_TEMPORARY;\n    access |= DELETE;\n  }\n\n  if (flags & UV_FS_O_SHORT_LIVED) {\n    attributes |= FILE_ATTRIBUTE_TEMPORARY;\n  }\n\n  switch (flags & (UV_FS_O_SEQUENTIAL | UV_FS_O_RANDOM)) {\n  case 0:\n    break;\n  case UV_FS_O_SEQUENTIAL:\n    attributes |= FILE_FLAG_SEQUENTIAL_SCAN;\n    break;\n  case UV_FS_O_RANDOM:\n    attributes |= FILE_FLAG_RANDOM_ACCESS;\n    break;\n  default:\n    goto einval;\n  }\n\n  if (flags & UV_FS_O_DIRECT) {\n    /*\n     * FILE_APPEND_DATA and FILE_FLAG_NO_BUFFERING are mutually exclusive.\n     * Windows returns 87, ERROR_INVALID_PARAMETER if these are combined.\n     *\n     * FILE_APPEND_DATA is included in FILE_GENERIC_WRITE:\n     *\n     * FILE_GENERIC_WRITE = STANDARD_RIGHTS_WRITE |\n     *                      FILE_WRITE_DATA |\n     *                      FILE_WRITE_ATTRIBUTES |\n     *                      FILE_WRITE_EA |\n     *                      FILE_APPEND_DATA |\n     *                      SYNCHRONIZE\n     *\n     * Note: Appends are also permitted by FILE_WRITE_DATA.\n     *\n     * In order for direct writes and direct appends to succeed, we therefore\n     * exclude FILE_APPEND_DATA if FILE_WRITE_DATA is specified, and otherwise\n     * fail if the user's sole permission is a direct append, since this\n     * particular combination is invalid.\n     */\n    if (access & FILE_APPEND_DATA) {\n      if (access & FILE_WRITE_DATA) {\n        access &= ~FILE_APPEND_DATA;\n      } else {\n        goto einval;\n      }\n    }\n    attributes |= FILE_FLAG_NO_BUFFERING;\n  }\n\n  switch (flags & (UV_FS_O_DSYNC | UV_FS_O_SYNC)) {\n  case 0:\n    break;\n  case UV_FS_O_DSYNC:\n  case UV_FS_O_SYNC:\n    attributes |= FILE_FLAG_WRITE_THROUGH;\n    break;\n  default:\n    goto einval;\n  }\n\n  /* Setting this flag makes it possible to open a directory. */\n  attributes |= FILE_FLAG_BACKUP_SEMANTICS;\n\n  file = CreateFileW(req->file.pathw,\n                     access,\n                     share,\n                     NULL,\n                     disposition,\n                     attributes,\n                     NULL);\n  if (file == INVALID_HANDLE_VALUE) {\n    DWORD error = GetLastError();\n    if (error == ERROR_FILE_EXISTS && (flags & UV_FS_O_CREAT) &&\n        !(flags & UV_FS_O_EXCL)) {\n      /* Special case: when ERROR_FILE_EXISTS happens and UV_FS_O_CREAT was\n       * specified, it means the path referred to a directory. */\n      SET_REQ_UV_ERROR(req, UV_EISDIR, error);\n    } else {\n      SET_REQ_WIN32_ERROR(req, GetLastError());\n    }\n    return;\n  }\n\n  fd = _open_osfhandle((intptr_t) file, flags);\n  if (fd < 0) {\n    /* The only known failure mode for _open_osfhandle() is EMFILE, in which\n     * case GetLastError() will return zero. However we'll try to handle other\n     * errors as well, should they ever occur.\n     */\n    if (errno == EMFILE)\n      SET_REQ_UV_ERROR(req, UV_EMFILE, ERROR_TOO_MANY_OPEN_FILES);\n    else if (GetLastError() != ERROR_SUCCESS)\n      SET_REQ_WIN32_ERROR(req, GetLastError());\n    else\n      SET_REQ_WIN32_ERROR(req, (DWORD) UV_UNKNOWN);\n    CloseHandle(file);\n    return;\n  }\n\n  if (flags & UV_FS_O_FILEMAP) {\n    FILE_STANDARD_INFO file_info;\n    if (!GetFileInformationByHandleEx(file,\n                                      FileStandardInfo,\n                                      &file_info,\n                                      sizeof file_info)) {\n      SET_REQ_WIN32_ERROR(req, GetLastError());\n      CloseHandle(file);\n      return;\n    }\n    fd_info.is_directory = file_info.Directory;\n\n    if (fd_info.is_directory) {\n      fd_info.size.QuadPart = 0;\n      fd_info.mapping = INVALID_HANDLE_VALUE;\n    } else {\n      if (!GetFileSizeEx(file, &fd_info.size)) {\n        SET_REQ_WIN32_ERROR(req, GetLastError());\n        CloseHandle(file);\n        return;\n      }\n\n      if (fd_info.size.QuadPart == 0) {\n        fd_info.mapping = INVALID_HANDLE_VALUE;\n      } else {\n        DWORD flProtect = (fd_info.flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY |\n          UV_FS_O_RDWR)) == UV_FS_O_RDONLY ? PAGE_READONLY : PAGE_READWRITE;\n        fd_info.mapping = CreateFileMapping(file,\n                                            NULL,\n                                            flProtect,\n                                            fd_info.size.HighPart,\n                                            fd_info.size.LowPart,\n                                            NULL);\n        if (fd_info.mapping == NULL) {\n          SET_REQ_WIN32_ERROR(req, GetLastError());\n          CloseHandle(file);\n          return;\n        }\n      }\n    }\n\n    uv__fd_hash_add(fd, &fd_info);\n  }\n\n  SET_REQ_RESULT(req, fd);\n  return;\n\n einval:\n  SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);\n}\n"
                    }
                }
            ]
        }
    },
    {
        "subtask": "\"实现创建可读写文件句柄并处理错误的函数是什么？\"",
        "results": {
            "query": "实现一个处理文件打开、关闭及错误情况的线程安全函数是什么？",
            "results": [
                {
                    "similarity": 0.5809846770176494,
                    "meta_info": {
                        "category": "Function",
                        "code": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  sigset_t signewset;\n  int close_fd;\n  int use_fd;\n  int fd;\n  int n;\n\n  /* Reset signal disposition first. Use a hard-coded limit because NSIG is not\n   * fixed on Linux: it's either 32, 34 or 64, depending on whether RT signals\n   * are enabled. We are not allowed to touch RT signal handlers, glibc uses\n   * them internally.\n   */\n  for (n = 1; n < 32; n += 1) {\n    if (n == SIGKILL || n == SIGSTOP)\n      continue;  /* Can't be changed. */\n\n#if defined(__HAIKU__)\n    if (n == SIGKILLTHR)\n      continue;  /* Can't be changed. */\n#endif\n\n    if (SIG_ERR != signal(n, SIG_DFL))\n      continue;\n\n    uv__write_errno(error_fd);\n  }\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  /* First duplicate low numbered fds, since it's not safe to duplicate them,\n   * they could get replaced. Example: swapping stdout and stderr; without\n   * this fd 2 (stderr) would be duplicated into fd 1, thus making both\n   * stdout and stderr go to the same fd, which was not the intention. */\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n    if (use_fd < 0 || use_fd >= fd)\n      continue;\n#ifdef F_DUPFD_CLOEXEC /* POSIX 2008 */\n    pipes[fd][1] = fcntl(use_fd, F_DUPFD_CLOEXEC, stdio_count);\n#else\n    pipes[fd][1] = fcntl(use_fd, F_DUPFD, stdio_count);\n#endif\n    if (pipes[fd][1] == -1)\n      uv__write_errno(error_fd);\n#ifndef F_DUPFD_CLOEXEC /* POSIX 2008 */\n    n = uv__cloexec(pipes[fd][1], 1);\n    if (n)\n      uv__write_int(error_fd, n);\n#endif\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = -1;\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* Redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set. */\n        uv__close_nocheckstdio(fd); /* Free up fd, if it happens to be open. */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd < 0)\n          uv__write_errno(error_fd);\n      }\n    }\n\n    if (fd == use_fd) {\n      if (close_fd == -1) {\n        n = uv__cloexec(use_fd, 0);\n        if (n)\n          uv__write_int(error_fd, n);\n      }\n    }\n    else {\n      fd = dup2(use_fd, fd);\n    }\n\n    if (fd == -1)\n      uv__write_errno(error_fd);\n\n    if (fd <= 2 && close_fd == -1)\n      uv__nonblock_fcntl(fd, 0);\n\n    if (close_fd >= stdio_count)\n      uv__close(close_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd))\n    uv__write_errno(error_fd);\n\n  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n    /* When dropping privileges from root, the `setgroups` call will\n     * remove any extraneous groups. If we don't call this, then\n     * even though our uid has dropped, we may still have groups\n     * that enable us to do super-user things. This will fail if we\n     * aren't root, so don't bother checking the return value, this\n     * is just done as an optimistic privilege dropping function.\n     */\n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid))\n    uv__write_errno(error_fd);\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid))\n    uv__write_errno(error_fd);\n\n  if (options->env != NULL)\n    environ = options->env;\n\n  /* Reset signal mask just before exec. */\n  sigemptyset(&signewset);\n  if (sigprocmask(SIG_SETMASK, &signewset, NULL) != 0)\n    abort();\n\n#ifdef __MVS__\n  execvpe(options->file, options->args, environ);\n#else\n  execvp(options->file, options->args);\n#endif\n\n  uv__write_errno(error_fd);\n}\n"
                    }
                },
                {
                    "similarity": 0.5786482095718384,
                    "meta_info": {
                        "category": "Function",
                        "code": "int uv_pipe_open(uv_pipe_t* pipe, uv_file file) {\n  HANDLE os_handle = uv__get_osfhandle(file);\n  NTSTATUS nt_status;\n  IO_STATUS_BLOCK io_status;\n  FILE_ACCESS_INFORMATION access;\n  DWORD duplex_flags = 0;\n  int err;\n\n  if (os_handle == INVALID_HANDLE_VALUE)\n    return UV_EBADF;\n  if (pipe->flags & UV_HANDLE_PIPESERVER)\n    return UV_EINVAL;\n  if (pipe->flags & UV_HANDLE_CONNECTION)\n    return UV_EBUSY;\n\n  uv__pipe_connection_init(pipe);\n  uv__once_init();\n  /* In order to avoid closing a stdio file descriptor 0-2, duplicate the\n   * underlying OS handle and forget about the original fd.\n   * We could also opt to use the original OS handle and just never close it,\n   * but then there would be no reliable way to cancel pending read operations\n   * upon close.\n   */\n  if (file <= 2) {\n    if (!DuplicateHandle(INVALID_HANDLE_VALUE,\n                         os_handle,\n                         INVALID_HANDLE_VALUE,\n                         &os_handle,\n                         0,\n                         FALSE,\n                         DUPLICATE_SAME_ACCESS))\n      return uv_translate_sys_error(GetLastError());\n    assert(os_handle != INVALID_HANDLE_VALUE);\n    file = -1;\n  }\n\n  /* Determine what kind of permissions we have on this handle.\n   * Cygwin opens the pipe in message mode, but we can support it,\n   * just query the access flags and set the stream flags accordingly.\n   */\n  nt_status = pNtQueryInformationFile(os_handle,\n                                      &io_status,\n                                      &access,\n                                      sizeof(access),\n                                      FileAccessInformation);\n  if (nt_status != STATUS_SUCCESS)\n    return UV_EINVAL;\n\n  if (pipe->ipc) {\n    if (!(access.AccessFlags & FILE_WRITE_DATA) ||\n        !(access.AccessFlags & FILE_READ_DATA)) {\n      return UV_EINVAL;\n    }\n  }\n\n  if (access.AccessFlags & FILE_WRITE_DATA)\n    duplex_flags |= UV_HANDLE_WRITABLE;\n  if (access.AccessFlags & FILE_READ_DATA)\n    duplex_flags |= UV_HANDLE_READABLE;\n\n  err = uv__set_pipe_handle(pipe->loop,\n                            pipe,\n                            os_handle,\n                            file,\n                            duplex_flags);\n  if (err) {\n    if (file == -1)\n      CloseHandle(os_handle);\n    return err;\n  }\n\n  if (pipe->ipc) {\n    assert(!(pipe->flags & UV_HANDLE_NON_OVERLAPPED_PIPE));\n    GetNamedPipeClientProcessId(os_handle, &pipe->pipe.conn.ipc_remote_pid);\n    if (pipe->pipe.conn.ipc_remote_pid == GetCurrentProcessId()) {\n      GetNamedPipeServerProcessId(os_handle, &pipe->pipe.conn.ipc_remote_pid);\n    }\n    assert(pipe->pipe.conn.ipc_remote_pid != (DWORD)(uv_pid_t) -1);\n  }\n  return 0;\n}\n"
                    }
                },
                {
                    "similarity": 0.5715731382369995,
                    "meta_info": {
                        "category": "Function",
                        "code": "static int uv__process_open_stream(uv_stdio_container_t* container,\n                                   int pipefds[2]) {\n  int flags;\n  int err;\n\n  if (!(container->flags & UV_CREATE_PIPE) || pipefds[0] < 0)\n    return 0;\n\n  err = uv__close(pipefds[1]);\n  if (err != 0)\n    abort();\n\n  pipefds[1] = -1;\n  uv__nonblock(pipefds[0], 1);\n\n  flags = 0;\n  if (container->flags & UV_WRITABLE_PIPE)\n    flags |= UV_HANDLE_READABLE;\n  if (container->flags & UV_READABLE_PIPE)\n    flags |= UV_HANDLE_WRITABLE;\n\n  return uv__stream_open(container->data.stream, pipefds[0], flags);\n}\n"
                    }
                },
                {
                    "similarity": 0.5659105777740479,
                    "meta_info": {
                        "category": "Function",
                        "code": "FILE* uv__open_file(const char* path) {\n  int fd;\n  FILE* fp;\n\n  fd = uv__open_cloexec(path, O_RDONLY);\n  if (fd < 0)\n    return NULL;\n\n   fp = fdopen(fd, \"r\");\n   if (fp == NULL)\n     uv__close(fd);\n\n   return fp;\n}\n"
                    }
                },
                {
                    "similarity": 0.5649750828742981,
                    "meta_info": {
                        "category": "Function",
                        "code": "void fs__open(uv_fs_t* req) {\n  DWORD access;\n  DWORD share;\n  DWORD disposition;\n  DWORD attributes = 0;\n  HANDLE file;\n  int fd, current_umask;\n  int flags = req->fs.info.file_flags;\n  struct uv__fd_info_s fd_info;\n\n  /* Adjust flags to be compatible with the memory file mapping. Save the\n   * original flags to emulate the correct behavior. */\n  if (flags & UV_FS_O_FILEMAP) {\n    fd_info.flags = flags;\n    fd_info.current_pos.QuadPart = 0;\n\n    if ((flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR)) ==\n        UV_FS_O_WRONLY) {\n      /* CreateFileMapping always needs read access */\n      flags = (flags & ~UV_FS_O_WRONLY) | UV_FS_O_RDWR;\n    }\n\n    if (flags & UV_FS_O_APPEND) {\n      /* Clear the append flag and ensure RDRW mode */\n      flags &= ~UV_FS_O_APPEND;\n      flags &= ~(UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR);\n      flags |= UV_FS_O_RDWR;\n    }\n  }\n\n  /* Obtain the active umask. umask() never fails and returns the previous\n   * umask. */\n  current_umask = _umask(0);\n  _umask(current_umask);\n\n  /* convert flags and mode to CreateFile parameters */\n  switch (flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR)) {\n  case UV_FS_O_RDONLY:\n    access = FILE_GENERIC_READ;\n    break;\n  case UV_FS_O_WRONLY:\n    access = FILE_GENERIC_WRITE;\n    break;\n  case UV_FS_O_RDWR:\n    access = FILE_GENERIC_READ | FILE_GENERIC_WRITE;\n    break;\n  default:\n    goto einval;\n  }\n\n  if (flags & UV_FS_O_APPEND) {\n    access &= ~FILE_WRITE_DATA;\n    access |= FILE_APPEND_DATA;\n  }\n\n  /*\n   * Here is where we deviate significantly from what CRT's _open()\n   * does. We indiscriminately use all the sharing modes, to match\n   * UNIX semantics. In particular, this ensures that the file can\n   * be deleted even whilst it's open, fixing issue\n   * https://github.com/nodejs/node-v0.x-archive/issues/1449.\n   * We still support exclusive sharing mode, since it is necessary\n   * for opening raw block devices, otherwise Windows will prevent\n   * any attempt to write past the master boot record.\n   */\n  if (flags & UV_FS_O_EXLOCK) {\n    share = 0;\n  } else {\n    share = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;\n  }\n\n  switch (flags & (UV_FS_O_CREAT | UV_FS_O_EXCL | UV_FS_O_TRUNC)) {\n  case 0:\n  case UV_FS_O_EXCL:\n    disposition = OPEN_EXISTING;\n    break;\n  case UV_FS_O_CREAT:\n    disposition = OPEN_ALWAYS;\n    break;\n  case UV_FS_O_CREAT | UV_FS_O_EXCL:\n  case UV_FS_O_CREAT | UV_FS_O_TRUNC | UV_FS_O_EXCL:\n    disposition = CREATE_NEW;\n    break;\n  case UV_FS_O_TRUNC:\n  case UV_FS_O_TRUNC | UV_FS_O_EXCL:\n    disposition = TRUNCATE_EXISTING;\n    break;\n  case UV_FS_O_CREAT | UV_FS_O_TRUNC:\n    disposition = CREATE_ALWAYS;\n    break;\n  default:\n    goto einval;\n  }\n\n  attributes |= FILE_ATTRIBUTE_NORMAL;\n  if (flags & UV_FS_O_CREAT) {\n    if (!((req->fs.info.mode & ~current_umask) & _S_IWRITE)) {\n      attributes |= FILE_ATTRIBUTE_READONLY;\n    }\n  }\n\n  if (flags & UV_FS_O_TEMPORARY ) {\n    attributes |= FILE_FLAG_DELETE_ON_CLOSE | FILE_ATTRIBUTE_TEMPORARY;\n    access |= DELETE;\n  }\n\n  if (flags & UV_FS_O_SHORT_LIVED) {\n    attributes |= FILE_ATTRIBUTE_TEMPORARY;\n  }\n\n  switch (flags & (UV_FS_O_SEQUENTIAL | UV_FS_O_RANDOM)) {\n  case 0:\n    break;\n  case UV_FS_O_SEQUENTIAL:\n    attributes |= FILE_FLAG_SEQUENTIAL_SCAN;\n    break;\n  case UV_FS_O_RANDOM:\n    attributes |= FILE_FLAG_RANDOM_ACCESS;\n    break;\n  default:\n    goto einval;\n  }\n\n  if (flags & UV_FS_O_DIRECT) {\n    /*\n     * FILE_APPEND_DATA and FILE_FLAG_NO_BUFFERING are mutually exclusive.\n     * Windows returns 87, ERROR_INVALID_PARAMETER if these are combined.\n     *\n     * FILE_APPEND_DATA is included in FILE_GENERIC_WRITE:\n     *\n     * FILE_GENERIC_WRITE = STANDARD_RIGHTS_WRITE |\n     *                      FILE_WRITE_DATA |\n     *                      FILE_WRITE_ATTRIBUTES |\n     *                      FILE_WRITE_EA |\n     *                      FILE_APPEND_DATA |\n     *                      SYNCHRONIZE\n     *\n     * Note: Appends are also permitted by FILE_WRITE_DATA.\n     *\n     * In order for direct writes and direct appends to succeed, we therefore\n     * exclude FILE_APPEND_DATA if FILE_WRITE_DATA is specified, and otherwise\n     * fail if the user's sole permission is a direct append, since this\n     * particular combination is invalid.\n     */\n    if (access & FILE_APPEND_DATA) {\n      if (access & FILE_WRITE_DATA) {\n        access &= ~FILE_APPEND_DATA;\n      } else {\n        goto einval;\n      }\n    }\n    attributes |= FILE_FLAG_NO_BUFFERING;\n  }\n\n  switch (flags & (UV_FS_O_DSYNC | UV_FS_O_SYNC)) {\n  case 0:\n    break;\n  case UV_FS_O_DSYNC:\n  case UV_FS_O_SYNC:\n    attributes |= FILE_FLAG_WRITE_THROUGH;\n    break;\n  default:\n    goto einval;\n  }\n\n  /* Setting this flag makes it possible to open a directory. */\n  attributes |= FILE_FLAG_BACKUP_SEMANTICS;\n\n  file = CreateFileW(req->file.pathw,\n                     access,\n                     share,\n                     NULL,\n                     disposition,\n                     attributes,\n                     NULL);\n  if (file == INVALID_HANDLE_VALUE) {\n    DWORD error = GetLastError();\n    if (error == ERROR_FILE_EXISTS && (flags & UV_FS_O_CREAT) &&\n        !(flags & UV_FS_O_EXCL)) {\n      /* Special case: when ERROR_FILE_EXISTS happens and UV_FS_O_CREAT was\n       * specified, it means the path referred to a directory. */\n      SET_REQ_UV_ERROR(req, UV_EISDIR, error);\n    } else {\n      SET_REQ_WIN32_ERROR(req, GetLastError());\n    }\n    return;\n  }\n\n  fd = _open_osfhandle((intptr_t) file, flags);\n  if (fd < 0) {\n    /* The only known failure mode for _open_osfhandle() is EMFILE, in which\n     * case GetLastError() will return zero. However we'll try to handle other\n     * errors as well, should they ever occur.\n     */\n    if (errno == EMFILE)\n      SET_REQ_UV_ERROR(req, UV_EMFILE, ERROR_TOO_MANY_OPEN_FILES);\n    else if (GetLastError() != ERROR_SUCCESS)\n      SET_REQ_WIN32_ERROR(req, GetLastError());\n    else\n      SET_REQ_WIN32_ERROR(req, (DWORD) UV_UNKNOWN);\n    CloseHandle(file);\n    return;\n  }\n\n  if (flags & UV_FS_O_FILEMAP) {\n    FILE_STANDARD_INFO file_info;\n    if (!GetFileInformationByHandleEx(file,\n                                      FileStandardInfo,\n                                      &file_info,\n                                      sizeof file_info)) {\n      SET_REQ_WIN32_ERROR(req, GetLastError());\n      CloseHandle(file);\n      return;\n    }\n    fd_info.is_directory = file_info.Directory;\n\n    if (fd_info.is_directory) {\n      fd_info.size.QuadPart = 0;\n      fd_info.mapping = INVALID_HANDLE_VALUE;\n    } else {\n      if (!GetFileSizeEx(file, &fd_info.size)) {\n        SET_REQ_WIN32_ERROR(req, GetLastError());\n        CloseHandle(file);\n        return;\n      }\n\n      if (fd_info.size.QuadPart == 0) {\n        fd_info.mapping = INVALID_HANDLE_VALUE;\n      } else {\n        DWORD flProtect = (fd_info.flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY |\n          UV_FS_O_RDWR)) == UV_FS_O_RDONLY ? PAGE_READONLY : PAGE_READWRITE;\n        fd_info.mapping = CreateFileMapping(file,\n                                            NULL,\n                                            flProtect,\n                                            fd_info.size.HighPart,\n                                            fd_info.size.LowPart,\n                                            NULL);\n        if (fd_info.mapping == NULL) {\n          SET_REQ_WIN32_ERROR(req, GetLastError());\n          CloseHandle(file);\n          return;\n        }\n      }\n    }\n\n    uv__fd_hash_add(fd, &fd_info);\n  }\n\n  SET_REQ_RESULT(req, fd);\n  return;\n\n einval:\n  SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);\n}\n"
                    }
                }
            ]
        }
    },
    {
        "subtask": "实现打开文件并初始化路径、权限、模式等属性，同时通过回调处理错误的函数是什么？",
        "results": {
            "query": "实现一个处理文件打开、关闭及错误情况的线程安全函数是什么？",
            "results": [
                {
                    "similarity": 0.5809846770176494,
                    "meta_info": {
                        "category": "Function",
                        "code": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  sigset_t signewset;\n  int close_fd;\n  int use_fd;\n  int fd;\n  int n;\n\n  /* Reset signal disposition first. Use a hard-coded limit because NSIG is not\n   * fixed on Linux: it's either 32, 34 or 64, depending on whether RT signals\n   * are enabled. We are not allowed to touch RT signal handlers, glibc uses\n   * them internally.\n   */\n  for (n = 1; n < 32; n += 1) {\n    if (n == SIGKILL || n == SIGSTOP)\n      continue;  /* Can't be changed. */\n\n#if defined(__HAIKU__)\n    if (n == SIGKILLTHR)\n      continue;  /* Can't be changed. */\n#endif\n\n    if (SIG_ERR != signal(n, SIG_DFL))\n      continue;\n\n    uv__write_errno(error_fd);\n  }\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  /* First duplicate low numbered fds, since it's not safe to duplicate them,\n   * they could get replaced. Example: swapping stdout and stderr; without\n   * this fd 2 (stderr) would be duplicated into fd 1, thus making both\n   * stdout and stderr go to the same fd, which was not the intention. */\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n    if (use_fd < 0 || use_fd >= fd)\n      continue;\n#ifdef F_DUPFD_CLOEXEC /* POSIX 2008 */\n    pipes[fd][1] = fcntl(use_fd, F_DUPFD_CLOEXEC, stdio_count);\n#else\n    pipes[fd][1] = fcntl(use_fd, F_DUPFD, stdio_count);\n#endif\n    if (pipes[fd][1] == -1)\n      uv__write_errno(error_fd);\n#ifndef F_DUPFD_CLOEXEC /* POSIX 2008 */\n    n = uv__cloexec(pipes[fd][1], 1);\n    if (n)\n      uv__write_int(error_fd, n);\n#endif\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = -1;\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* Redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set. */\n        uv__close_nocheckstdio(fd); /* Free up fd, if it happens to be open. */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd < 0)\n          uv__write_errno(error_fd);\n      }\n    }\n\n    if (fd == use_fd) {\n      if (close_fd == -1) {\n        n = uv__cloexec(use_fd, 0);\n        if (n)\n          uv__write_int(error_fd, n);\n      }\n    }\n    else {\n      fd = dup2(use_fd, fd);\n    }\n\n    if (fd == -1)\n      uv__write_errno(error_fd);\n\n    if (fd <= 2 && close_fd == -1)\n      uv__nonblock_fcntl(fd, 0);\n\n    if (close_fd >= stdio_count)\n      uv__close(close_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd))\n    uv__write_errno(error_fd);\n\n  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n    /* When dropping privileges from root, the `setgroups` call will\n     * remove any extraneous groups. If we don't call this, then\n     * even though our uid has dropped, we may still have groups\n     * that enable us to do super-user things. This will fail if we\n     * aren't root, so don't bother checking the return value, this\n     * is just done as an optimistic privilege dropping function.\n     */\n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid))\n    uv__write_errno(error_fd);\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid))\n    uv__write_errno(error_fd);\n\n  if (options->env != NULL)\n    environ = options->env;\n\n  /* Reset signal mask just before exec. */\n  sigemptyset(&signewset);\n  if (sigprocmask(SIG_SETMASK, &signewset, NULL) != 0)\n    abort();\n\n#ifdef __MVS__\n  execvpe(options->file, options->args, environ);\n#else\n  execvp(options->file, options->args);\n#endif\n\n  uv__write_errno(error_fd);\n}\n"
                    }
                },
                {
                    "similarity": 0.5786482095718384,
                    "meta_info": {
                        "category": "Function",
                        "code": "int uv_pipe_open(uv_pipe_t* pipe, uv_file file) {\n  HANDLE os_handle = uv__get_osfhandle(file);\n  NTSTATUS nt_status;\n  IO_STATUS_BLOCK io_status;\n  FILE_ACCESS_INFORMATION access;\n  DWORD duplex_flags = 0;\n  int err;\n\n  if (os_handle == INVALID_HANDLE_VALUE)\n    return UV_EBADF;\n  if (pipe->flags & UV_HANDLE_PIPESERVER)\n    return UV_EINVAL;\n  if (pipe->flags & UV_HANDLE_CONNECTION)\n    return UV_EBUSY;\n\n  uv__pipe_connection_init(pipe);\n  uv__once_init();\n  /* In order to avoid closing a stdio file descriptor 0-2, duplicate the\n   * underlying OS handle and forget about the original fd.\n   * We could also opt to use the original OS handle and just never close it,\n   * but then there would be no reliable way to cancel pending read operations\n   * upon close.\n   */\n  if (file <= 2) {\n    if (!DuplicateHandle(INVALID_HANDLE_VALUE,\n                         os_handle,\n                         INVALID_HANDLE_VALUE,\n                         &os_handle,\n                         0,\n                         FALSE,\n                         DUPLICATE_SAME_ACCESS))\n      return uv_translate_sys_error(GetLastError());\n    assert(os_handle != INVALID_HANDLE_VALUE);\n    file = -1;\n  }\n\n  /* Determine what kind of permissions we have on this handle.\n   * Cygwin opens the pipe in message mode, but we can support it,\n   * just query the access flags and set the stream flags accordingly.\n   */\n  nt_status = pNtQueryInformationFile(os_handle,\n                                      &io_status,\n                                      &access,\n                                      sizeof(access),\n                                      FileAccessInformation);\n  if (nt_status != STATUS_SUCCESS)\n    return UV_EINVAL;\n\n  if (pipe->ipc) {\n    if (!(access.AccessFlags & FILE_WRITE_DATA) ||\n        !(access.AccessFlags & FILE_READ_DATA)) {\n      return UV_EINVAL;\n    }\n  }\n\n  if (access.AccessFlags & FILE_WRITE_DATA)\n    duplex_flags |= UV_HANDLE_WRITABLE;\n  if (access.AccessFlags & FILE_READ_DATA)\n    duplex_flags |= UV_HANDLE_READABLE;\n\n  err = uv__set_pipe_handle(pipe->loop,\n                            pipe,\n                            os_handle,\n                            file,\n                            duplex_flags);\n  if (err) {\n    if (file == -1)\n      CloseHandle(os_handle);\n    return err;\n  }\n\n  if (pipe->ipc) {\n    assert(!(pipe->flags & UV_HANDLE_NON_OVERLAPPED_PIPE));\n    GetNamedPipeClientProcessId(os_handle, &pipe->pipe.conn.ipc_remote_pid);\n    if (pipe->pipe.conn.ipc_remote_pid == GetCurrentProcessId()) {\n      GetNamedPipeServerProcessId(os_handle, &pipe->pipe.conn.ipc_remote_pid);\n    }\n    assert(pipe->pipe.conn.ipc_remote_pid != (DWORD)(uv_pid_t) -1);\n  }\n  return 0;\n}\n"
                    }
                },
                {
                    "similarity": 0.5715731382369995,
                    "meta_info": {
                        "category": "Function",
                        "code": "static int uv__process_open_stream(uv_stdio_container_t* container,\n                                   int pipefds[2]) {\n  int flags;\n  int err;\n\n  if (!(container->flags & UV_CREATE_PIPE) || pipefds[0] < 0)\n    return 0;\n\n  err = uv__close(pipefds[1]);\n  if (err != 0)\n    abort();\n\n  pipefds[1] = -1;\n  uv__nonblock(pipefds[0], 1);\n\n  flags = 0;\n  if (container->flags & UV_WRITABLE_PIPE)\n    flags |= UV_HANDLE_READABLE;\n  if (container->flags & UV_READABLE_PIPE)\n    flags |= UV_HANDLE_WRITABLE;\n\n  return uv__stream_open(container->data.stream, pipefds[0], flags);\n}\n"
                    }
                },
                {
                    "similarity": 0.5659105777740479,
                    "meta_info": {
                        "category": "Function",
                        "code": "FILE* uv__open_file(const char* path) {\n  int fd;\n  FILE* fp;\n\n  fd = uv__open_cloexec(path, O_RDONLY);\n  if (fd < 0)\n    return NULL;\n\n   fp = fdopen(fd, \"r\");\n   if (fp == NULL)\n     uv__close(fd);\n\n   return fp;\n}\n"
                    }
                },
                {
                    "similarity": 0.5649750828742981,
                    "meta_info": {
                        "category": "Function",
                        "code": "void fs__open(uv_fs_t* req) {\n  DWORD access;\n  DWORD share;\n  DWORD disposition;\n  DWORD attributes = 0;\n  HANDLE file;\n  int fd, current_umask;\n  int flags = req->fs.info.file_flags;\n  struct uv__fd_info_s fd_info;\n\n  /* Adjust flags to be compatible with the memory file mapping. Save the\n   * original flags to emulate the correct behavior. */\n  if (flags & UV_FS_O_FILEMAP) {\n    fd_info.flags = flags;\n    fd_info.current_pos.QuadPart = 0;\n\n    if ((flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR)) ==\n        UV_FS_O_WRONLY) {\n      /* CreateFileMapping always needs read access */\n      flags = (flags & ~UV_FS_O_WRONLY) | UV_FS_O_RDWR;\n    }\n\n    if (flags & UV_FS_O_APPEND) {\n      /* Clear the append flag and ensure RDRW mode */\n      flags &= ~UV_FS_O_APPEND;\n      flags &= ~(UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR);\n      flags |= UV_FS_O_RDWR;\n    }\n  }\n\n  /* Obtain the active umask. umask() never fails and returns the previous\n   * umask. */\n  current_umask = _umask(0);\n  _umask(current_umask);\n\n  /* convert flags and mode to CreateFile parameters */\n  switch (flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR)) {\n  case UV_FS_O_RDONLY:\n    access = FILE_GENERIC_READ;\n    break;\n  case UV_FS_O_WRONLY:\n    access = FILE_GENERIC_WRITE;\n    break;\n  case UV_FS_O_RDWR:\n    access = FILE_GENERIC_READ | FILE_GENERIC_WRITE;\n    break;\n  default:\n    goto einval;\n  }\n\n  if (flags & UV_FS_O_APPEND) {\n    access &= ~FILE_WRITE_DATA;\n    access |= FILE_APPEND_DATA;\n  }\n\n  /*\n   * Here is where we deviate significantly from what CRT's _open()\n   * does. We indiscriminately use all the sharing modes, to match\n   * UNIX semantics. In particular, this ensures that the file can\n   * be deleted even whilst it's open, fixing issue\n   * https://github.com/nodejs/node-v0.x-archive/issues/1449.\n   * We still support exclusive sharing mode, since it is necessary\n   * for opening raw block devices, otherwise Windows will prevent\n   * any attempt to write past the master boot record.\n   */\n  if (flags & UV_FS_O_EXLOCK) {\n    share = 0;\n  } else {\n    share = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;\n  }\n\n  switch (flags & (UV_FS_O_CREAT | UV_FS_O_EXCL | UV_FS_O_TRUNC)) {\n  case 0:\n  case UV_FS_O_EXCL:\n    disposition = OPEN_EXISTING;\n    break;\n  case UV_FS_O_CREAT:\n    disposition = OPEN_ALWAYS;\n    break;\n  case UV_FS_O_CREAT | UV_FS_O_EXCL:\n  case UV_FS_O_CREAT | UV_FS_O_TRUNC | UV_FS_O_EXCL:\n    disposition = CREATE_NEW;\n    break;\n  case UV_FS_O_TRUNC:\n  case UV_FS_O_TRUNC | UV_FS_O_EXCL:\n    disposition = TRUNCATE_EXISTING;\n    break;\n  case UV_FS_O_CREAT | UV_FS_O_TRUNC:\n    disposition = CREATE_ALWAYS;\n    break;\n  default:\n    goto einval;\n  }\n\n  attributes |= FILE_ATTRIBUTE_NORMAL;\n  if (flags & UV_FS_O_CREAT) {\n    if (!((req->fs.info.mode & ~current_umask) & _S_IWRITE)) {\n      attributes |= FILE_ATTRIBUTE_READONLY;\n    }\n  }\n\n  if (flags & UV_FS_O_TEMPORARY ) {\n    attributes |= FILE_FLAG_DELETE_ON_CLOSE | FILE_ATTRIBUTE_TEMPORARY;\n    access |= DELETE;\n  }\n\n  if (flags & UV_FS_O_SHORT_LIVED) {\n    attributes |= FILE_ATTRIBUTE_TEMPORARY;\n  }\n\n  switch (flags & (UV_FS_O_SEQUENTIAL | UV_FS_O_RANDOM)) {\n  case 0:\n    break;\n  case UV_FS_O_SEQUENTIAL:\n    attributes |= FILE_FLAG_SEQUENTIAL_SCAN;\n    break;\n  case UV_FS_O_RANDOM:\n    attributes |= FILE_FLAG_RANDOM_ACCESS;\n    break;\n  default:\n    goto einval;\n  }\n\n  if (flags & UV_FS_O_DIRECT) {\n    /*\n     * FILE_APPEND_DATA and FILE_FLAG_NO_BUFFERING are mutually exclusive.\n     * Windows returns 87, ERROR_INVALID_PARAMETER if these are combined.\n     *\n     * FILE_APPEND_DATA is included in FILE_GENERIC_WRITE:\n     *\n     * FILE_GENERIC_WRITE = STANDARD_RIGHTS_WRITE |\n     *                      FILE_WRITE_DATA |\n     *                      FILE_WRITE_ATTRIBUTES |\n     *                      FILE_WRITE_EA |\n     *                      FILE_APPEND_DATA |\n     *                      SYNCHRONIZE\n     *\n     * Note: Appends are also permitted by FILE_WRITE_DATA.\n     *\n     * In order for direct writes and direct appends to succeed, we therefore\n     * exclude FILE_APPEND_DATA if FILE_WRITE_DATA is specified, and otherwise\n     * fail if the user's sole permission is a direct append, since this\n     * particular combination is invalid.\n     */\n    if (access & FILE_APPEND_DATA) {\n      if (access & FILE_WRITE_DATA) {\n        access &= ~FILE_APPEND_DATA;\n      } else {\n        goto einval;\n      }\n    }\n    attributes |= FILE_FLAG_NO_BUFFERING;\n  }\n\n  switch (flags & (UV_FS_O_DSYNC | UV_FS_O_SYNC)) {\n  case 0:\n    break;\n  case UV_FS_O_DSYNC:\n  case UV_FS_O_SYNC:\n    attributes |= FILE_FLAG_WRITE_THROUGH;\n    break;\n  default:\n    goto einval;\n  }\n\n  /* Setting this flag makes it possible to open a directory. */\n  attributes |= FILE_FLAG_BACKUP_SEMANTICS;\n\n  file = CreateFileW(req->file.pathw,\n                     access,\n                     share,\n                     NULL,\n                     disposition,\n                     attributes,\n                     NULL);\n  if (file == INVALID_HANDLE_VALUE) {\n    DWORD error = GetLastError();\n    if (error == ERROR_FILE_EXISTS && (flags & UV_FS_O_CREAT) &&\n        !(flags & UV_FS_O_EXCL)) {\n      /* Special case: when ERROR_FILE_EXISTS happens and UV_FS_O_CREAT was\n       * specified, it means the path referred to a directory. */\n      SET_REQ_UV_ERROR(req, UV_EISDIR, error);\n    } else {\n      SET_REQ_WIN32_ERROR(req, GetLastError());\n    }\n    return;\n  }\n\n  fd = _open_osfhandle((intptr_t) file, flags);\n  if (fd < 0) {\n    /* The only known failure mode for _open_osfhandle() is EMFILE, in which\n     * case GetLastError() will return zero. However we'll try to handle other\n     * errors as well, should they ever occur.\n     */\n    if (errno == EMFILE)\n      SET_REQ_UV_ERROR(req, UV_EMFILE, ERROR_TOO_MANY_OPEN_FILES);\n    else if (GetLastError() != ERROR_SUCCESS)\n      SET_REQ_WIN32_ERROR(req, GetLastError());\n    else\n      SET_REQ_WIN32_ERROR(req, (DWORD) UV_UNKNOWN);\n    CloseHandle(file);\n    return;\n  }\n\n  if (flags & UV_FS_O_FILEMAP) {\n    FILE_STANDARD_INFO file_info;\n    if (!GetFileInformationByHandleEx(file,\n                                      FileStandardInfo,\n                                      &file_info,\n                                      sizeof file_info)) {\n      SET_REQ_WIN32_ERROR(req, GetLastError());\n      CloseHandle(file);\n      return;\n    }\n    fd_info.is_directory = file_info.Directory;\n\n    if (fd_info.is_directory) {\n      fd_info.size.QuadPart = 0;\n      fd_info.mapping = INVALID_HANDLE_VALUE;\n    } else {\n      if (!GetFileSizeEx(file, &fd_info.size)) {\n        SET_REQ_WIN32_ERROR(req, GetLastError());\n        CloseHandle(file);\n        return;\n      }\n\n      if (fd_info.size.QuadPart == 0) {\n        fd_info.mapping = INVALID_HANDLE_VALUE;\n      } else {\n        DWORD flProtect = (fd_info.flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY |\n          UV_FS_O_RDWR)) == UV_FS_O_RDONLY ? PAGE_READONLY : PAGE_READWRITE;\n        fd_info.mapping = CreateFileMapping(file,\n                                            NULL,\n                                            flProtect,\n                                            fd_info.size.HighPart,\n                                            fd_info.size.LowPart,\n                                            NULL);\n        if (fd_info.mapping == NULL) {\n          SET_REQ_WIN32_ERROR(req, GetLastError());\n          CloseHandle(file);\n          return;\n        }\n      }\n    }\n\n    uv__fd_hash_add(fd, &fd_info);\n  }\n\n  SET_REQ_RESULT(req, fd);\n  return;\n\n einval:\n  SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);\n}\n"
                    }
                }
            ]
        }
    }
]