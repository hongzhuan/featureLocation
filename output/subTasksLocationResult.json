[
    {
        "subtask": "实现初始化和管理I/O事件队列、处理文件描述符事件及维护相关指针的函数是什么？",
        "results": {
            "query": "实现初始化和管理I/O事件队列、处理文件描述符事件及维护相关指针的函数是什么？",
            "results": [
                {
                    "similarity": 0.5643660685797899,
                    "meta_info": {
                        "category": "Function",
                        "code": "static int uv__pipe_write_data(uv_loop_t* loop,\n                               uv_write_t* req,\n                               uv_pipe_t* handle,\n                               const uv_buf_t bufs[],\n                               size_t nbufs,\n                               uv_write_cb cb,\n                               int copy_always) {\n  int err;\n  int result;\n  uv_buf_t write_buf;\n\n  assert(handle->handle != INVALID_HANDLE_VALUE);\n\n  UV_REQ_INIT(req, UV_WRITE);\n  req->handle = (uv_stream_t*) handle;\n  req->send_handle = NULL;\n  req->cb = cb;\n  /* Private fields. */\n  req->coalesced = 0;\n  req->event_handle = NULL;\n  req->wait_handle = INVALID_HANDLE_VALUE;\n\n  /* Prepare the overlapped structure. */\n  memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));\n  if (handle->flags & (UV_HANDLE_EMULATE_IOCP | UV_HANDLE_BLOCKING_WRITES)) {\n    req->event_handle = CreateEvent(NULL, 0, 0, NULL);\n    if (req->event_handle == NULL) {\n      uv_fatal_error(GetLastError(), \"CreateEvent\");\n    }\n    req->u.io.overlapped.hEvent = (HANDLE) ((uintptr_t) req->event_handle | 1);\n  }\n  req->write_buffer = uv_null_buf_;\n\n  if (nbufs == 0) {\n    /* Write empty buffer. */\n    write_buf = uv_null_buf_;\n  } else if (nbufs == 1 && !copy_always) {\n    /* Write directly from bufs[0]. */\n    write_buf = bufs[0];\n  } else {\n    /* Coalesce all `bufs` into one big buffer. This also creates a new\n     * write-request structure that replaces the old one. */\n    err = uv__build_coalesced_write_req(req, bufs, nbufs, &req, &write_buf);\n    if (err != 0)\n      return err;\n  }\n\n  if ((handle->flags &\n      (UV_HANDLE_BLOCKING_WRITES | UV_HANDLE_NON_OVERLAPPED_PIPE)) ==\n      (UV_HANDLE_BLOCKING_WRITES | UV_HANDLE_NON_OVERLAPPED_PIPE)) {\n    DWORD bytes;\n    result =\n        WriteFile(handle->handle, write_buf.base, write_buf.len, &bytes, NULL);\n\n    if (!result) {\n      err = GetLastError();\n      return err;\n    } else {\n      /* Request completed immediately. */\n      req->u.io.queued_bytes = 0;\n    }\n\n    REGISTER_HANDLE_REQ(loop, handle, req);\n    handle->reqs_pending++;\n    handle->stream.conn.write_reqs_pending++;\n    POST_COMPLETION_FOR_REQ(loop, req);\n    return 0;\n  } else if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {\n    req->write_buffer = write_buf;\n    uv__insert_non_overlapped_write_req(handle, req);\n    if (handle->stream.conn.write_reqs_pending == 0) {\n      uv__queue_non_overlapped_write(handle);\n    }\n\n    /* Request queued by the kernel. */\n    req->u.io.queued_bytes = write_buf.len;\n    handle->write_queue_size += req->u.io.queued_bytes;\n  } else if (handle->flags & UV_HANDLE_BLOCKING_WRITES) {\n    /* Using overlapped IO, but wait for completion before returning */\n    result = WriteFile(handle->handle,\n                       write_buf.base,\n                       write_buf.len,\n                       NULL,\n                       &req->u.io.overlapped);\n\n    if (!result && GetLastError() != ERROR_IO_PENDING) {\n      err = GetLastError();\n      CloseHandle(req->event_handle);\n      req->event_handle = NULL;\n      return err;\n    }\n\n    if (result) {\n      /* Request completed immediately. */\n      req->u.io.queued_bytes = 0;\n    } else {\n      /* Request queued by the kernel. */\n      req->u.io.queued_bytes = write_buf.len;\n      handle->write_queue_size += req->u.io.queued_bytes;\n      if (WaitForSingleObject(req->event_handle, INFINITE) !=\n          WAIT_OBJECT_0) {\n        err = GetLastError();\n        CloseHandle(req->event_handle);\n        req->event_handle = NULL;\n        return err;\n      }\n    }\n    CloseHandle(req->event_handle);\n    req->event_handle = NULL;\n\n    REGISTER_HANDLE_REQ(loop, handle, req);\n    handle->reqs_pending++;\n    handle->stream.conn.write_reqs_pending++;\n    return 0;\n  } else {\n    result = WriteFile(handle->handle,\n                       write_buf.base,\n                       write_buf.len,\n                       NULL,\n                       &req->u.io.overlapped);\n\n    if (!result && GetLastError() != ERROR_IO_PENDING) {\n      return GetLastError();\n    }\n\n    if (result) {\n      /* Request completed immediately. */\n      req->u.io.queued_bytes = 0;\n    } else {\n      /* Request queued by the kernel. */\n      req->u.io.queued_bytes = write_buf.len;\n      handle->write_queue_size += req->u.io.queued_bytes;\n    }\n\n    if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n      if (!RegisterWaitForSingleObject(&req->wait_handle,\n          req->event_handle, post_completion_write_wait, (void*) req,\n          INFINITE, WT_EXECUTEINWAITTHREAD)) {\n        return GetLastError();\n      }\n    }\n  }\n\n  REGISTER_HANDLE_REQ(loop, handle, req);\n  handle->reqs_pending++;\n  handle->stream.conn.write_reqs_pending++;\n\n  return 0;\n}\n"
                    }
                },
                {
                    "similarity": 0.5580167437781854,
                    "meta_info": {
                        "category": "Function",
                        "code": "int uv__pipe_write_ipc(uv_loop_t* loop,\n                       uv_write_t* req,\n                       uv_pipe_t* handle,\n                       const uv_buf_t data_bufs[],\n                       size_t data_buf_count,\n                       uv_stream_t* send_handle,\n                       uv_write_cb cb) {\n  uv_buf_t stack_bufs[6];\n  uv_buf_t* bufs;\n  size_t buf_count, buf_index;\n  uv__ipc_frame_header_t frame_header;\n  uv__ipc_socket_xfer_type_t xfer_type = UV__IPC_SOCKET_XFER_NONE;\n  uv__ipc_socket_xfer_info_t xfer_info;\n  uint64_t data_length;\n  size_t i;\n  int err;\n\n  /* Compute the combined size of data buffers. */\n  data_length = 0;\n  for (i = 0; i < data_buf_count; i++)\n    data_length += data_bufs[i].len;\n  if (data_length > UINT32_MAX)\n    return WSAENOBUFS; /* Maps to UV_ENOBUFS. */\n\n  /* Prepare the frame's socket xfer payload. */\n  if (send_handle != NULL) {\n    uv_tcp_t* send_tcp_handle = (uv_tcp_t*) send_handle;\n\n    /* Verify that `send_handle` it is indeed a tcp handle. */\n    if (send_tcp_handle->type != UV_TCP)\n      return ERROR_NOT_SUPPORTED;\n\n    /* Export the tcp handle. */\n    err = uv__tcp_xfer_export(send_tcp_handle,\n                              uv__pipe_get_ipc_remote_pid(handle),\n                              &xfer_type,\n                              &xfer_info);\n    if (err != 0)\n      return err;\n  }\n\n  /* Compute the number of uv_buf_t's required. */\n  buf_count = 1 + data_buf_count; /* Frame header and data buffers. */\n  if (send_handle != NULL)\n    buf_count += 1; /* One extra for the socket xfer information. */\n\n  /* Use the on-stack buffer array if it is big enough; otherwise allocate\n   * space for it on the heap. */\n  if (buf_count < ARRAY_SIZE(stack_bufs)) {\n    /* Use on-stack buffer array. */\n    bufs = stack_bufs;\n  } else {\n    /* Use heap-allocated buffer array. */\n    bufs = uv__calloc(buf_count, sizeof(uv_buf_t));\n    if (bufs == NULL)\n      return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */\n  }\n  buf_index = 0;\n\n  /* Initialize frame header and add it to the buffers list. */\n  memset(&frame_header, 0, sizeof frame_header);\n  bufs[buf_index++] = uv_buf_init((char*) &frame_header, sizeof frame_header);\n\n  if (send_handle != NULL) {\n    /* Add frame header flags. */\n    switch (xfer_type) {\n      case UV__IPC_SOCKET_XFER_TCP_CONNECTION:\n        frame_header.flags |= UV__IPC_FRAME_HAS_SOCKET_XFER |\n                              UV__IPC_FRAME_XFER_IS_TCP_CONNECTION;\n        break;\n      case UV__IPC_SOCKET_XFER_TCP_SERVER:\n        frame_header.flags |= UV__IPC_FRAME_HAS_SOCKET_XFER;\n        break;\n      default:\n        assert(0);  /* Unreachable. */\n    }\n    /* Add xfer info buffer. */\n    bufs[buf_index++] = uv_buf_init((char*) &xfer_info, sizeof xfer_info);\n  }\n\n  if (data_length > 0) {\n    /* Update frame header. */\n    frame_header.flags |= UV__IPC_FRAME_HAS_DATA;\n    frame_header.data_length = (uint32_t) data_length;\n    /* Add data buffers to buffers list. */\n    for (i = 0; i < data_buf_count; i++)\n      bufs[buf_index++] = data_bufs[i];\n  }\n\n  /* Write buffers. We set the `always_copy` flag, so it is not a problem that\n   * some of the written data lives on the stack. */\n  err = uv__pipe_write_data(loop, req, handle, bufs, buf_count, cb, 1);\n\n  /* If we had to heap-allocate the bufs array, free it now. */\n  if (bufs != stack_bufs) {\n    uv__free(bufs);\n  }\n\n  return err;\n}\n"
                    }
                },
                {
                    "similarity": 0.5544514325588098,
                    "meta_info": {
                        "category": "Function",
                        "code": "static void fs__create_junction(uv_fs_t* req, const WCHAR* path,\n    const WCHAR* new_path) {\n  HANDLE handle = INVALID_HANDLE_VALUE;\n  REPARSE_DATA_BUFFER *buffer = NULL;\n  int created = 0;\n  int target_len;\n  int is_absolute, is_long_path;\n  int needed_buf_size, used_buf_size, used_data_size, path_buf_len;\n  int start, len, i;\n  int add_slash;\n  DWORD bytes;\n  WCHAR* path_buf;\n\n  target_len = wcslen(path);\n  is_long_path = wcsncmp(path, LONG_PATH_PREFIX, LONG_PATH_PREFIX_LEN) == 0;\n\n  if (is_long_path) {\n    is_absolute = 1;\n  } else {\n    is_absolute = target_len >= 3 && IS_LETTER(path[0]) &&\n      path[1] == L':' && IS_SLASH(path[2]);\n  }\n\n  if (!is_absolute) {\n    /* Not supporting relative paths */\n    SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_NOT_SUPPORTED);\n    return;\n  }\n\n  /* Do a pessimistic calculation of the required buffer size */\n  needed_buf_size =\n      FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) +\n      JUNCTION_PREFIX_LEN * sizeof(WCHAR) +\n      2 * (target_len + 2) * sizeof(WCHAR);\n\n  /* Allocate the buffer */\n  buffer = (REPARSE_DATA_BUFFER*)uv__malloc(needed_buf_size);\n  if (!buffer) {\n    uv_fatal_error(ERROR_OUTOFMEMORY, \"uv__malloc\");\n  }\n\n  /* Grab a pointer to the part of the buffer where filenames go */\n  path_buf = (WCHAR*)&(buffer->MountPointReparseBuffer.PathBuffer);\n  path_buf_len = 0;\n\n  /* Copy the substitute (internal) target path */\n  start = path_buf_len;\n\n  wcsncpy((WCHAR*)&path_buf[path_buf_len], JUNCTION_PREFIX,\n    JUNCTION_PREFIX_LEN);\n  path_buf_len += JUNCTION_PREFIX_LEN;\n\n  add_slash = 0;\n  for (i = is_long_path ? LONG_PATH_PREFIX_LEN : 0; path[i] != L'\\0'; i++) {\n    if (IS_SLASH(path[i])) {\n      add_slash = 1;\n      continue;\n    }\n\n    if (add_slash) {\n      path_buf[path_buf_len++] = L'\\\\';\n      add_slash = 0;\n    }\n\n    path_buf[path_buf_len++] = path[i];\n  }\n  path_buf[path_buf_len++] = L'\\\\';\n  len = path_buf_len - start;\n\n  /* Set the info about the substitute name */\n  buffer->MountPointReparseBuffer.SubstituteNameOffset = start * sizeof(WCHAR);\n  buffer->MountPointReparseBuffer.SubstituteNameLength = len * sizeof(WCHAR);\n\n  /* Insert null terminator */\n  path_buf[path_buf_len++] = L'\\0';\n\n  /* Copy the print name of the target path */\n  start = path_buf_len;\n  add_slash = 0;\n  for (i = is_long_path ? LONG_PATH_PREFIX_LEN : 0; path[i] != L'\\0'; i++) {\n    if (IS_SLASH(path[i])) {\n      add_slash = 1;\n      continue;\n    }\n\n    if (add_slash) {\n      path_buf[path_buf_len++] = L'\\\\';\n      add_slash = 0;\n    }\n\n    path_buf[path_buf_len++] = path[i];\n  }\n  len = path_buf_len - start;\n  if (len == 2) {\n    path_buf[path_buf_len++] = L'\\\\';\n    len++;\n  }\n\n  /* Set the info about the print name */\n  buffer->MountPointReparseBuffer.PrintNameOffset = start * sizeof(WCHAR);\n  buffer->MountPointReparseBuffer.PrintNameLength = len * sizeof(WCHAR);\n\n  /* Insert another null terminator */\n  path_buf[path_buf_len++] = L'\\0';\n\n  /* Calculate how much buffer space was actually used */\n  used_buf_size = FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) +\n    path_buf_len * sizeof(WCHAR);\n  used_data_size = used_buf_size -\n    FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer);\n\n  /* Put general info in the data buffer */\n  buffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n  buffer->ReparseDataLength = used_data_size;\n  buffer->Reserved = 0;\n\n  /* Create a new directory */\n  if (!CreateDirectoryW(new_path, NULL)) {\n    SET_REQ_WIN32_ERROR(req, GetLastError());\n    goto error;\n  }\n  created = 1;\n\n  /* Open the directory */\n  handle = CreateFileW(new_path,\n                       GENERIC_WRITE,\n                       0,\n                       NULL,\n                       OPEN_EXISTING,\n                       FILE_FLAG_BACKUP_SEMANTICS |\n                         FILE_FLAG_OPEN_REPARSE_POINT,\n                       NULL);\n  if (handle == INVALID_HANDLE_VALUE) {\n    SET_REQ_WIN32_ERROR(req, GetLastError());\n    goto error;\n  }\n\n  /* Create the actual reparse point */\n  if (!DeviceIoControl(handle,\n                       FSCTL_SET_REPARSE_POINT,\n                       buffer,\n                       used_buf_size,\n                       NULL,\n                       0,\n                       &bytes,\n                       NULL)) {\n    SET_REQ_WIN32_ERROR(req, GetLastError());\n    goto error;\n  }\n\n  /* Clean up */\n  CloseHandle(handle);\n  uv__free(buffer);\n\n  SET_REQ_RESULT(req, 0);\n  return;\n\nerror:\n  uv__free(buffer);\n\n  if (handle != INVALID_HANDLE_VALUE) {\n    CloseHandle(handle);\n  }\n\n  if (created) {\n    RemoveDirectoryW(new_path);\n  }\n}\n"
                    }
                },
                {
                    "similarity": 0.55231886478438,
                    "meta_info": {
                        "category": "Function",
                        "code": "INLINE static int fs__readlink_handle(HANDLE handle,\n                                      char** target_ptr,\n                                      size_t* target_len_ptr) {\n  char buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n  REPARSE_DATA_BUFFER* reparse_data = (REPARSE_DATA_BUFFER*) buffer;\n  WCHAR* w_target;\n  DWORD w_target_len;\n  DWORD bytes;\n  size_t i;\n  size_t len;\n\n  if (!DeviceIoControl(handle,\n                       FSCTL_GET_REPARSE_POINT,\n                       NULL,\n                       0,\n                       buffer,\n                       sizeof buffer,\n                       &bytes,\n                       NULL)) {\n    return -1;\n  }\n\n  if (reparse_data->ReparseTag == IO_REPARSE_TAG_SYMLINK) {\n    /* Real symlink */\n    w_target = reparse_data->SymbolicLinkReparseBuffer.PathBuffer +\n        (reparse_data->SymbolicLinkReparseBuffer.SubstituteNameOffset /\n        sizeof(WCHAR));\n    w_target_len =\n        reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength /\n        sizeof(WCHAR);\n\n    /* Real symlinks can contain pretty much everything, but the only thing we\n     * really care about is undoing the implicit conversion to an NT namespaced\n     * path that CreateSymbolicLink will perform on absolute paths. If the path\n     * is win32-namespaced then the user must have explicitly made it so, and\n     * we better just return the unmodified reparse data. */\n    if (w_target_len >= 4 &&\n        w_target[0] == L'\\\\' &&\n        w_target[1] == L'?' &&\n        w_target[2] == L'?' &&\n        w_target[3] == L'\\\\') {\n      /* Starts with \\??\\ */\n      if (w_target_len >= 6 &&\n          ((w_target[4] >= L'A' && w_target[4] <= L'Z') ||\n           (w_target[4] >= L'a' && w_target[4] <= L'z')) &&\n          w_target[5] == L':' &&\n          (w_target_len == 6 || w_target[6] == L'\\\\')) {\n        /* \\??\\<drive>:\\ */\n        w_target += 4;\n        w_target_len -= 4;\n\n      } else if (w_target_len >= 8 &&\n                 (w_target[4] == L'U' || w_target[4] == L'u') &&\n                 (w_target[5] == L'N' || w_target[5] == L'n') &&\n                 (w_target[6] == L'C' || w_target[6] == L'c') &&\n                 w_target[7] == L'\\\\') {\n        /* \\??\\UNC\\<server>\\<share>\\ - make sure the final path looks like\n         * \\\\<server>\\<share>\\ */\n        w_target += 6;\n        w_target[0] = L'\\\\';\n        w_target_len -= 6;\n      }\n    }\n\n  } else if (reparse_data->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {\n    /* Junction. */\n    w_target = reparse_data->MountPointReparseBuffer.PathBuffer +\n        (reparse_data->MountPointReparseBuffer.SubstituteNameOffset /\n        sizeof(WCHAR));\n    w_target_len = reparse_data->MountPointReparseBuffer.SubstituteNameLength /\n        sizeof(WCHAR);\n\n    /* Only treat junctions that look like \\??\\<drive>:\\ as symlink. Junctions\n     * can also be used as mount points, like \\??\\Volume{<guid>}, but that's\n     * confusing for programs since they wouldn't be able to actually\n     * understand such a path when returned by uv_readlink(). UNC paths are\n     * never valid for junctions so we don't care about them. */\n    if (!(w_target_len >= 6 &&\n          w_target[0] == L'\\\\' &&\n          w_target[1] == L'?' &&\n          w_target[2] == L'?' &&\n          w_target[3] == L'\\\\' &&\n          ((w_target[4] >= L'A' && w_target[4] <= L'Z') ||\n           (w_target[4] >= L'a' && w_target[4] <= L'z')) &&\n          w_target[5] == L':' &&\n          (w_target_len == 6 || w_target[6] == L'\\\\'))) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n\n    /* Remove leading \\??\\ */\n    w_target += 4;\n    w_target_len -= 4;\n\n  } else if (reparse_data->ReparseTag == IO_REPARSE_TAG_APPEXECLINK) {\n    /* String #3 in the list has the target filename. */\n    if (reparse_data->AppExecLinkReparseBuffer.StringCount < 3) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n    w_target = reparse_data->AppExecLinkReparseBuffer.StringList;\n    /* The StringList buffer contains a list of strings separated by \"\\0\",   */\n    /* with \"\\0\\0\" terminating the list. Move to the 3rd string in the list: */\n    for (i = 0; i < 2; ++i) {\n      len = wcslen(w_target);\n      if (len == 0) {\n        SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n        return -1;\n      }\n      w_target += len + 1;\n    }\n    w_target_len = wcslen(w_target);\n    if (w_target_len == 0) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n    /* Make sure it is an absolute path. */\n    if (!(w_target_len >= 3 &&\n         ((w_target[0] >= L'a' && w_target[0] <= L'z') ||\n          (w_target[0] >= L'A' && w_target[0] <= L'Z')) &&\n         w_target[1] == L':' &&\n         w_target[2] == L'\\\\')) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n\n  } else {\n    /* Reparse tag does not indicate a symlink. */\n    SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n    return -1;\n  }\n\n  assert(target_ptr == NULL || *target_ptr == NULL);\n  return uv_utf16_to_wtf8(w_target, w_target_len, target_ptr, target_len_ptr);\n}\n"
                    }
                },
                {
                    "similarity": 0.5515046119689941,
                    "meta_info": {
                        "category": "Function",
                        "code": "static void uv__iou_init(int epollfd,\n                         struct uv__iou* iou,\n                         uint32_t entries,\n                         uint32_t flags) {\n  struct uv__io_uring_params params;\n  struct epoll_event e;\n  size_t cqlen;\n  size_t sqlen;\n  size_t maxlen;\n  size_t sqelen;\n  uint32_t i;\n  char* sq;\n  char* sqe;\n  int ringfd;\n\n  sq = MAP_FAILED;\n  sqe = MAP_FAILED;\n\n  if (!uv__use_io_uring())\n    return;\n\n  /* SQPOLL required CAP_SYS_NICE until linux v5.12 relaxed that requirement.\n   * Mostly academic because we check for a v5.13 kernel afterwards anyway.\n   */\n  memset(&params, 0, sizeof(params));\n  params.flags = flags;\n\n  if (flags & UV__IORING_SETUP_SQPOLL)\n    params.sq_thread_idle = 10;  /* milliseconds */\n\n  /* Kernel returns a file descriptor with O_CLOEXEC flag set. */\n  ringfd = uv__io_uring_setup(entries, &params);\n  if (ringfd == -1)\n    return;\n\n  /* IORING_FEAT_RSRC_TAGS is used to detect linux v5.13 but what we're\n   * actually detecting is whether IORING_OP_STATX works with SQPOLL.\n   */\n  if (!(params.features & UV__IORING_FEAT_RSRC_TAGS))\n    goto fail;\n\n  /* Implied by IORING_FEAT_RSRC_TAGS but checked explicitly anyway. */\n  if (!(params.features & UV__IORING_FEAT_SINGLE_MMAP))\n    goto fail;\n\n  /* Implied by IORING_FEAT_RSRC_TAGS but checked explicitly anyway. */\n  if (!(params.features & UV__IORING_FEAT_NODROP))\n    goto fail;\n\n  sqlen = params.sq_off.array + params.sq_entries * sizeof(uint32_t);\n  cqlen =\n      params.cq_off.cqes + params.cq_entries * sizeof(struct uv__io_uring_cqe);\n  maxlen = sqlen < cqlen ? cqlen : sqlen;\n  sqelen = params.sq_entries * sizeof(struct uv__io_uring_sqe);\n\n  sq = mmap(0,\n            maxlen,\n            PROT_READ | PROT_WRITE,\n            MAP_SHARED | MAP_POPULATE,\n            ringfd,\n            0);  /* IORING_OFF_SQ_RING */\n\n  sqe = mmap(0,\n             sqelen,\n             PROT_READ | PROT_WRITE,\n             MAP_SHARED | MAP_POPULATE,\n             ringfd,\n             0x10000000ull);  /* IORING_OFF_SQES */\n\n  if (sq == MAP_FAILED || sqe == MAP_FAILED)\n    goto fail;\n\n  if (flags & UV__IORING_SETUP_SQPOLL) {\n    /* Only interested in completion events. To get notified when\n     * the kernel pulls items from the submission ring, add POLLOUT.\n     */\n    memset(&e, 0, sizeof(e));\n    e.events = POLLIN;\n    e.data.fd = ringfd;\n\n    if (uv__epoll_ctl(epollfd, EPOLL_CTL_ADD, ringfd, &e))\n      goto fail;\n  }\n\n  iou->sqhead = (uint32_t*) (sq + params.sq_off.head);\n  iou->sqtail = (uint32_t*) (sq + params.sq_off.tail);\n  iou->sqmask = *(uint32_t*) (sq + params.sq_off.ring_mask);\n  iou->sqarray = (uint32_t*) (sq + params.sq_off.array);\n  iou->sqflags = (uint32_t*) (sq + params.sq_off.flags);\n  iou->cqhead = (uint32_t*) (sq + params.cq_off.head);\n  iou->cqtail = (uint32_t*) (sq + params.cq_off.tail);\n  iou->cqmask = *(uint32_t*) (sq + params.cq_off.ring_mask);\n  iou->sq = sq;\n  iou->cqe = sq + params.cq_off.cqes;\n  iou->sqe = sqe;\n  iou->sqlen = sqlen;\n  iou->cqlen = cqlen;\n  iou->maxlen = maxlen;\n  iou->sqelen = sqelen;\n  iou->ringfd = ringfd;\n  iou->in_flight = 0;\n  iou->flags = 0;\n\n  if (uv__kernel_version() >= /* 5.15.0 */ 0x050F00)\n    iou->flags |= UV__MKDIRAT_SYMLINKAT_LINKAT;\n\n  for (i = 0; i <= iou->sqmask; i++)\n    iou->sqarray[i] = i;  /* Slot -> sqe identity mapping. */\n\n  return;\n\nfail:\n  if (sq != MAP_FAILED)\n    munmap(sq, maxlen);\n\n  if (sqe != MAP_FAILED)\n    munmap(sqe, sqelen);\n\n  uv__close(ringfd);\n}\n"
                    }
                }
            ]
        }
    },
    {
        "subtask": "\"实现一个在高危权限环境中处理特定事件、传递内部事件到外层轮询操作并根据结果提交给外层处理的函数是什么？\"",
        "results": {
            "query": "实现初始化和管理I/O事件队列、处理文件描述符事件及维护相关指针的函数是什么？",
            "results": [
                {
                    "similarity": 0.5643660685797899,
                    "meta_info": {
                        "category": "Function",
                        "code": "static int uv__pipe_write_data(uv_loop_t* loop,\n                               uv_write_t* req,\n                               uv_pipe_t* handle,\n                               const uv_buf_t bufs[],\n                               size_t nbufs,\n                               uv_write_cb cb,\n                               int copy_always) {\n  int err;\n  int result;\n  uv_buf_t write_buf;\n\n  assert(handle->handle != INVALID_HANDLE_VALUE);\n\n  UV_REQ_INIT(req, UV_WRITE);\n  req->handle = (uv_stream_t*) handle;\n  req->send_handle = NULL;\n  req->cb = cb;\n  /* Private fields. */\n  req->coalesced = 0;\n  req->event_handle = NULL;\n  req->wait_handle = INVALID_HANDLE_VALUE;\n\n  /* Prepare the overlapped structure. */\n  memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));\n  if (handle->flags & (UV_HANDLE_EMULATE_IOCP | UV_HANDLE_BLOCKING_WRITES)) {\n    req->event_handle = CreateEvent(NULL, 0, 0, NULL);\n    if (req->event_handle == NULL) {\n      uv_fatal_error(GetLastError(), \"CreateEvent\");\n    }\n    req->u.io.overlapped.hEvent = (HANDLE) ((uintptr_t) req->event_handle | 1);\n  }\n  req->write_buffer = uv_null_buf_;\n\n  if (nbufs == 0) {\n    /* Write empty buffer. */\n    write_buf = uv_null_buf_;\n  } else if (nbufs == 1 && !copy_always) {\n    /* Write directly from bufs[0]. */\n    write_buf = bufs[0];\n  } else {\n    /* Coalesce all `bufs` into one big buffer. This also creates a new\n     * write-request structure that replaces the old one. */\n    err = uv__build_coalesced_write_req(req, bufs, nbufs, &req, &write_buf);\n    if (err != 0)\n      return err;\n  }\n\n  if ((handle->flags &\n      (UV_HANDLE_BLOCKING_WRITES | UV_HANDLE_NON_OVERLAPPED_PIPE)) ==\n      (UV_HANDLE_BLOCKING_WRITES | UV_HANDLE_NON_OVERLAPPED_PIPE)) {\n    DWORD bytes;\n    result =\n        WriteFile(handle->handle, write_buf.base, write_buf.len, &bytes, NULL);\n\n    if (!result) {\n      err = GetLastError();\n      return err;\n    } else {\n      /* Request completed immediately. */\n      req->u.io.queued_bytes = 0;\n    }\n\n    REGISTER_HANDLE_REQ(loop, handle, req);\n    handle->reqs_pending++;\n    handle->stream.conn.write_reqs_pending++;\n    POST_COMPLETION_FOR_REQ(loop, req);\n    return 0;\n  } else if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {\n    req->write_buffer = write_buf;\n    uv__insert_non_overlapped_write_req(handle, req);\n    if (handle->stream.conn.write_reqs_pending == 0) {\n      uv__queue_non_overlapped_write(handle);\n    }\n\n    /* Request queued by the kernel. */\n    req->u.io.queued_bytes = write_buf.len;\n    handle->write_queue_size += req->u.io.queued_bytes;\n  } else if (handle->flags & UV_HANDLE_BLOCKING_WRITES) {\n    /* Using overlapped IO, but wait for completion before returning */\n    result = WriteFile(handle->handle,\n                       write_buf.base,\n                       write_buf.len,\n                       NULL,\n                       &req->u.io.overlapped);\n\n    if (!result && GetLastError() != ERROR_IO_PENDING) {\n      err = GetLastError();\n      CloseHandle(req->event_handle);\n      req->event_handle = NULL;\n      return err;\n    }\n\n    if (result) {\n      /* Request completed immediately. */\n      req->u.io.queued_bytes = 0;\n    } else {\n      /* Request queued by the kernel. */\n      req->u.io.queued_bytes = write_buf.len;\n      handle->write_queue_size += req->u.io.queued_bytes;\n      if (WaitForSingleObject(req->event_handle, INFINITE) !=\n          WAIT_OBJECT_0) {\n        err = GetLastError();\n        CloseHandle(req->event_handle);\n        req->event_handle = NULL;\n        return err;\n      }\n    }\n    CloseHandle(req->event_handle);\n    req->event_handle = NULL;\n\n    REGISTER_HANDLE_REQ(loop, handle, req);\n    handle->reqs_pending++;\n    handle->stream.conn.write_reqs_pending++;\n    return 0;\n  } else {\n    result = WriteFile(handle->handle,\n                       write_buf.base,\n                       write_buf.len,\n                       NULL,\n                       &req->u.io.overlapped);\n\n    if (!result && GetLastError() != ERROR_IO_PENDING) {\n      return GetLastError();\n    }\n\n    if (result) {\n      /* Request completed immediately. */\n      req->u.io.queued_bytes = 0;\n    } else {\n      /* Request queued by the kernel. */\n      req->u.io.queued_bytes = write_buf.len;\n      handle->write_queue_size += req->u.io.queued_bytes;\n    }\n\n    if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n      if (!RegisterWaitForSingleObject(&req->wait_handle,\n          req->event_handle, post_completion_write_wait, (void*) req,\n          INFINITE, WT_EXECUTEINWAITTHREAD)) {\n        return GetLastError();\n      }\n    }\n  }\n\n  REGISTER_HANDLE_REQ(loop, handle, req);\n  handle->reqs_pending++;\n  handle->stream.conn.write_reqs_pending++;\n\n  return 0;\n}\n"
                    }
                },
                {
                    "similarity": 0.5580167437781854,
                    "meta_info": {
                        "category": "Function",
                        "code": "int uv__pipe_write_ipc(uv_loop_t* loop,\n                       uv_write_t* req,\n                       uv_pipe_t* handle,\n                       const uv_buf_t data_bufs[],\n                       size_t data_buf_count,\n                       uv_stream_t* send_handle,\n                       uv_write_cb cb) {\n  uv_buf_t stack_bufs[6];\n  uv_buf_t* bufs;\n  size_t buf_count, buf_index;\n  uv__ipc_frame_header_t frame_header;\n  uv__ipc_socket_xfer_type_t xfer_type = UV__IPC_SOCKET_XFER_NONE;\n  uv__ipc_socket_xfer_info_t xfer_info;\n  uint64_t data_length;\n  size_t i;\n  int err;\n\n  /* Compute the combined size of data buffers. */\n  data_length = 0;\n  for (i = 0; i < data_buf_count; i++)\n    data_length += data_bufs[i].len;\n  if (data_length > UINT32_MAX)\n    return WSAENOBUFS; /* Maps to UV_ENOBUFS. */\n\n  /* Prepare the frame's socket xfer payload. */\n  if (send_handle != NULL) {\n    uv_tcp_t* send_tcp_handle = (uv_tcp_t*) send_handle;\n\n    /* Verify that `send_handle` it is indeed a tcp handle. */\n    if (send_tcp_handle->type != UV_TCP)\n      return ERROR_NOT_SUPPORTED;\n\n    /* Export the tcp handle. */\n    err = uv__tcp_xfer_export(send_tcp_handle,\n                              uv__pipe_get_ipc_remote_pid(handle),\n                              &xfer_type,\n                              &xfer_info);\n    if (err != 0)\n      return err;\n  }\n\n  /* Compute the number of uv_buf_t's required. */\n  buf_count = 1 + data_buf_count; /* Frame header and data buffers. */\n  if (send_handle != NULL)\n    buf_count += 1; /* One extra for the socket xfer information. */\n\n  /* Use the on-stack buffer array if it is big enough; otherwise allocate\n   * space for it on the heap. */\n  if (buf_count < ARRAY_SIZE(stack_bufs)) {\n    /* Use on-stack buffer array. */\n    bufs = stack_bufs;\n  } else {\n    /* Use heap-allocated buffer array. */\n    bufs = uv__calloc(buf_count, sizeof(uv_buf_t));\n    if (bufs == NULL)\n      return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */\n  }\n  buf_index = 0;\n\n  /* Initialize frame header and add it to the buffers list. */\n  memset(&frame_header, 0, sizeof frame_header);\n  bufs[buf_index++] = uv_buf_init((char*) &frame_header, sizeof frame_header);\n\n  if (send_handle != NULL) {\n    /* Add frame header flags. */\n    switch (xfer_type) {\n      case UV__IPC_SOCKET_XFER_TCP_CONNECTION:\n        frame_header.flags |= UV__IPC_FRAME_HAS_SOCKET_XFER |\n                              UV__IPC_FRAME_XFER_IS_TCP_CONNECTION;\n        break;\n      case UV__IPC_SOCKET_XFER_TCP_SERVER:\n        frame_header.flags |= UV__IPC_FRAME_HAS_SOCKET_XFER;\n        break;\n      default:\n        assert(0);  /* Unreachable. */\n    }\n    /* Add xfer info buffer. */\n    bufs[buf_index++] = uv_buf_init((char*) &xfer_info, sizeof xfer_info);\n  }\n\n  if (data_length > 0) {\n    /* Update frame header. */\n    frame_header.flags |= UV__IPC_FRAME_HAS_DATA;\n    frame_header.data_length = (uint32_t) data_length;\n    /* Add data buffers to buffers list. */\n    for (i = 0; i < data_buf_count; i++)\n      bufs[buf_index++] = data_bufs[i];\n  }\n\n  /* Write buffers. We set the `always_copy` flag, so it is not a problem that\n   * some of the written data lives on the stack. */\n  err = uv__pipe_write_data(loop, req, handle, bufs, buf_count, cb, 1);\n\n  /* If we had to heap-allocate the bufs array, free it now. */\n  if (bufs != stack_bufs) {\n    uv__free(bufs);\n  }\n\n  return err;\n}\n"
                    }
                },
                {
                    "similarity": 0.5544514325588098,
                    "meta_info": {
                        "category": "Function",
                        "code": "static void fs__create_junction(uv_fs_t* req, const WCHAR* path,\n    const WCHAR* new_path) {\n  HANDLE handle = INVALID_HANDLE_VALUE;\n  REPARSE_DATA_BUFFER *buffer = NULL;\n  int created = 0;\n  int target_len;\n  int is_absolute, is_long_path;\n  int needed_buf_size, used_buf_size, used_data_size, path_buf_len;\n  int start, len, i;\n  int add_slash;\n  DWORD bytes;\n  WCHAR* path_buf;\n\n  target_len = wcslen(path);\n  is_long_path = wcsncmp(path, LONG_PATH_PREFIX, LONG_PATH_PREFIX_LEN) == 0;\n\n  if (is_long_path) {\n    is_absolute = 1;\n  } else {\n    is_absolute = target_len >= 3 && IS_LETTER(path[0]) &&\n      path[1] == L':' && IS_SLASH(path[2]);\n  }\n\n  if (!is_absolute) {\n    /* Not supporting relative paths */\n    SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_NOT_SUPPORTED);\n    return;\n  }\n\n  /* Do a pessimistic calculation of the required buffer size */\n  needed_buf_size =\n      FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) +\n      JUNCTION_PREFIX_LEN * sizeof(WCHAR) +\n      2 * (target_len + 2) * sizeof(WCHAR);\n\n  /* Allocate the buffer */\n  buffer = (REPARSE_DATA_BUFFER*)uv__malloc(needed_buf_size);\n  if (!buffer) {\n    uv_fatal_error(ERROR_OUTOFMEMORY, \"uv__malloc\");\n  }\n\n  /* Grab a pointer to the part of the buffer where filenames go */\n  path_buf = (WCHAR*)&(buffer->MountPointReparseBuffer.PathBuffer);\n  path_buf_len = 0;\n\n  /* Copy the substitute (internal) target path */\n  start = path_buf_len;\n\n  wcsncpy((WCHAR*)&path_buf[path_buf_len], JUNCTION_PREFIX,\n    JUNCTION_PREFIX_LEN);\n  path_buf_len += JUNCTION_PREFIX_LEN;\n\n  add_slash = 0;\n  for (i = is_long_path ? LONG_PATH_PREFIX_LEN : 0; path[i] != L'\\0'; i++) {\n    if (IS_SLASH(path[i])) {\n      add_slash = 1;\n      continue;\n    }\n\n    if (add_slash) {\n      path_buf[path_buf_len++] = L'\\\\';\n      add_slash = 0;\n    }\n\n    path_buf[path_buf_len++] = path[i];\n  }\n  path_buf[path_buf_len++] = L'\\\\';\n  len = path_buf_len - start;\n\n  /* Set the info about the substitute name */\n  buffer->MountPointReparseBuffer.SubstituteNameOffset = start * sizeof(WCHAR);\n  buffer->MountPointReparseBuffer.SubstituteNameLength = len * sizeof(WCHAR);\n\n  /* Insert null terminator */\n  path_buf[path_buf_len++] = L'\\0';\n\n  /* Copy the print name of the target path */\n  start = path_buf_len;\n  add_slash = 0;\n  for (i = is_long_path ? LONG_PATH_PREFIX_LEN : 0; path[i] != L'\\0'; i++) {\n    if (IS_SLASH(path[i])) {\n      add_slash = 1;\n      continue;\n    }\n\n    if (add_slash) {\n      path_buf[path_buf_len++] = L'\\\\';\n      add_slash = 0;\n    }\n\n    path_buf[path_buf_len++] = path[i];\n  }\n  len = path_buf_len - start;\n  if (len == 2) {\n    path_buf[path_buf_len++] = L'\\\\';\n    len++;\n  }\n\n  /* Set the info about the print name */\n  buffer->MountPointReparseBuffer.PrintNameOffset = start * sizeof(WCHAR);\n  buffer->MountPointReparseBuffer.PrintNameLength = len * sizeof(WCHAR);\n\n  /* Insert another null terminator */\n  path_buf[path_buf_len++] = L'\\0';\n\n  /* Calculate how much buffer space was actually used */\n  used_buf_size = FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) +\n    path_buf_len * sizeof(WCHAR);\n  used_data_size = used_buf_size -\n    FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer);\n\n  /* Put general info in the data buffer */\n  buffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n  buffer->ReparseDataLength = used_data_size;\n  buffer->Reserved = 0;\n\n  /* Create a new directory */\n  if (!CreateDirectoryW(new_path, NULL)) {\n    SET_REQ_WIN32_ERROR(req, GetLastError());\n    goto error;\n  }\n  created = 1;\n\n  /* Open the directory */\n  handle = CreateFileW(new_path,\n                       GENERIC_WRITE,\n                       0,\n                       NULL,\n                       OPEN_EXISTING,\n                       FILE_FLAG_BACKUP_SEMANTICS |\n                         FILE_FLAG_OPEN_REPARSE_POINT,\n                       NULL);\n  if (handle == INVALID_HANDLE_VALUE) {\n    SET_REQ_WIN32_ERROR(req, GetLastError());\n    goto error;\n  }\n\n  /* Create the actual reparse point */\n  if (!DeviceIoControl(handle,\n                       FSCTL_SET_REPARSE_POINT,\n                       buffer,\n                       used_buf_size,\n                       NULL,\n                       0,\n                       &bytes,\n                       NULL)) {\n    SET_REQ_WIN32_ERROR(req, GetLastError());\n    goto error;\n  }\n\n  /* Clean up */\n  CloseHandle(handle);\n  uv__free(buffer);\n\n  SET_REQ_RESULT(req, 0);\n  return;\n\nerror:\n  uv__free(buffer);\n\n  if (handle != INVALID_HANDLE_VALUE) {\n    CloseHandle(handle);\n  }\n\n  if (created) {\n    RemoveDirectoryW(new_path);\n  }\n}\n"
                    }
                },
                {
                    "similarity": 0.55231886478438,
                    "meta_info": {
                        "category": "Function",
                        "code": "INLINE static int fs__readlink_handle(HANDLE handle,\n                                      char** target_ptr,\n                                      size_t* target_len_ptr) {\n  char buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n  REPARSE_DATA_BUFFER* reparse_data = (REPARSE_DATA_BUFFER*) buffer;\n  WCHAR* w_target;\n  DWORD w_target_len;\n  DWORD bytes;\n  size_t i;\n  size_t len;\n\n  if (!DeviceIoControl(handle,\n                       FSCTL_GET_REPARSE_POINT,\n                       NULL,\n                       0,\n                       buffer,\n                       sizeof buffer,\n                       &bytes,\n                       NULL)) {\n    return -1;\n  }\n\n  if (reparse_data->ReparseTag == IO_REPARSE_TAG_SYMLINK) {\n    /* Real symlink */\n    w_target = reparse_data->SymbolicLinkReparseBuffer.PathBuffer +\n        (reparse_data->SymbolicLinkReparseBuffer.SubstituteNameOffset /\n        sizeof(WCHAR));\n    w_target_len =\n        reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength /\n        sizeof(WCHAR);\n\n    /* Real symlinks can contain pretty much everything, but the only thing we\n     * really care about is undoing the implicit conversion to an NT namespaced\n     * path that CreateSymbolicLink will perform on absolute paths. If the path\n     * is win32-namespaced then the user must have explicitly made it so, and\n     * we better just return the unmodified reparse data. */\n    if (w_target_len >= 4 &&\n        w_target[0] == L'\\\\' &&\n        w_target[1] == L'?' &&\n        w_target[2] == L'?' &&\n        w_target[3] == L'\\\\') {\n      /* Starts with \\??\\ */\n      if (w_target_len >= 6 &&\n          ((w_target[4] >= L'A' && w_target[4] <= L'Z') ||\n           (w_target[4] >= L'a' && w_target[4] <= L'z')) &&\n          w_target[5] == L':' &&\n          (w_target_len == 6 || w_target[6] == L'\\\\')) {\n        /* \\??\\<drive>:\\ */\n        w_target += 4;\n        w_target_len -= 4;\n\n      } else if (w_target_len >= 8 &&\n                 (w_target[4] == L'U' || w_target[4] == L'u') &&\n                 (w_target[5] == L'N' || w_target[5] == L'n') &&\n                 (w_target[6] == L'C' || w_target[6] == L'c') &&\n                 w_target[7] == L'\\\\') {\n        /* \\??\\UNC\\<server>\\<share>\\ - make sure the final path looks like\n         * \\\\<server>\\<share>\\ */\n        w_target += 6;\n        w_target[0] = L'\\\\';\n        w_target_len -= 6;\n      }\n    }\n\n  } else if (reparse_data->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {\n    /* Junction. */\n    w_target = reparse_data->MountPointReparseBuffer.PathBuffer +\n        (reparse_data->MountPointReparseBuffer.SubstituteNameOffset /\n        sizeof(WCHAR));\n    w_target_len = reparse_data->MountPointReparseBuffer.SubstituteNameLength /\n        sizeof(WCHAR);\n\n    /* Only treat junctions that look like \\??\\<drive>:\\ as symlink. Junctions\n     * can also be used as mount points, like \\??\\Volume{<guid>}, but that's\n     * confusing for programs since they wouldn't be able to actually\n     * understand such a path when returned by uv_readlink(). UNC paths are\n     * never valid for junctions so we don't care about them. */\n    if (!(w_target_len >= 6 &&\n          w_target[0] == L'\\\\' &&\n          w_target[1] == L'?' &&\n          w_target[2] == L'?' &&\n          w_target[3] == L'\\\\' &&\n          ((w_target[4] >= L'A' && w_target[4] <= L'Z') ||\n           (w_target[4] >= L'a' && w_target[4] <= L'z')) &&\n          w_target[5] == L':' &&\n          (w_target_len == 6 || w_target[6] == L'\\\\'))) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n\n    /* Remove leading \\??\\ */\n    w_target += 4;\n    w_target_len -= 4;\n\n  } else if (reparse_data->ReparseTag == IO_REPARSE_TAG_APPEXECLINK) {\n    /* String #3 in the list has the target filename. */\n    if (reparse_data->AppExecLinkReparseBuffer.StringCount < 3) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n    w_target = reparse_data->AppExecLinkReparseBuffer.StringList;\n    /* The StringList buffer contains a list of strings separated by \"\\0\",   */\n    /* with \"\\0\\0\" terminating the list. Move to the 3rd string in the list: */\n    for (i = 0; i < 2; ++i) {\n      len = wcslen(w_target);\n      if (len == 0) {\n        SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n        return -1;\n      }\n      w_target += len + 1;\n    }\n    w_target_len = wcslen(w_target);\n    if (w_target_len == 0) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n    /* Make sure it is an absolute path. */\n    if (!(w_target_len >= 3 &&\n         ((w_target[0] >= L'a' && w_target[0] <= L'z') ||\n          (w_target[0] >= L'A' && w_target[0] <= L'Z')) &&\n         w_target[1] == L':' &&\n         w_target[2] == L'\\\\')) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n\n  } else {\n    /* Reparse tag does not indicate a symlink. */\n    SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n    return -1;\n  }\n\n  assert(target_ptr == NULL || *target_ptr == NULL);\n  return uv_utf16_to_wtf8(w_target, w_target_len, target_ptr, target_len_ptr);\n}\n"
                    }
                },
                {
                    "similarity": 0.5515046119689941,
                    "meta_info": {
                        "category": "Function",
                        "code": "static void uv__iou_init(int epollfd,\n                         struct uv__iou* iou,\n                         uint32_t entries,\n                         uint32_t flags) {\n  struct uv__io_uring_params params;\n  struct epoll_event e;\n  size_t cqlen;\n  size_t sqlen;\n  size_t maxlen;\n  size_t sqelen;\n  uint32_t i;\n  char* sq;\n  char* sqe;\n  int ringfd;\n\n  sq = MAP_FAILED;\n  sqe = MAP_FAILED;\n\n  if (!uv__use_io_uring())\n    return;\n\n  /* SQPOLL required CAP_SYS_NICE until linux v5.12 relaxed that requirement.\n   * Mostly academic because we check for a v5.13 kernel afterwards anyway.\n   */\n  memset(&params, 0, sizeof(params));\n  params.flags = flags;\n\n  if (flags & UV__IORING_SETUP_SQPOLL)\n    params.sq_thread_idle = 10;  /* milliseconds */\n\n  /* Kernel returns a file descriptor with O_CLOEXEC flag set. */\n  ringfd = uv__io_uring_setup(entries, &params);\n  if (ringfd == -1)\n    return;\n\n  /* IORING_FEAT_RSRC_TAGS is used to detect linux v5.13 but what we're\n   * actually detecting is whether IORING_OP_STATX works with SQPOLL.\n   */\n  if (!(params.features & UV__IORING_FEAT_RSRC_TAGS))\n    goto fail;\n\n  /* Implied by IORING_FEAT_RSRC_TAGS but checked explicitly anyway. */\n  if (!(params.features & UV__IORING_FEAT_SINGLE_MMAP))\n    goto fail;\n\n  /* Implied by IORING_FEAT_RSRC_TAGS but checked explicitly anyway. */\n  if (!(params.features & UV__IORING_FEAT_NODROP))\n    goto fail;\n\n  sqlen = params.sq_off.array + params.sq_entries * sizeof(uint32_t);\n  cqlen =\n      params.cq_off.cqes + params.cq_entries * sizeof(struct uv__io_uring_cqe);\n  maxlen = sqlen < cqlen ? cqlen : sqlen;\n  sqelen = params.sq_entries * sizeof(struct uv__io_uring_sqe);\n\n  sq = mmap(0,\n            maxlen,\n            PROT_READ | PROT_WRITE,\n            MAP_SHARED | MAP_POPULATE,\n            ringfd,\n            0);  /* IORING_OFF_SQ_RING */\n\n  sqe = mmap(0,\n             sqelen,\n             PROT_READ | PROT_WRITE,\n             MAP_SHARED | MAP_POPULATE,\n             ringfd,\n             0x10000000ull);  /* IORING_OFF_SQES */\n\n  if (sq == MAP_FAILED || sqe == MAP_FAILED)\n    goto fail;\n\n  if (flags & UV__IORING_SETUP_SQPOLL) {\n    /* Only interested in completion events. To get notified when\n     * the kernel pulls items from the submission ring, add POLLOUT.\n     */\n    memset(&e, 0, sizeof(e));\n    e.events = POLLIN;\n    e.data.fd = ringfd;\n\n    if (uv__epoll_ctl(epollfd, EPOLL_CTL_ADD, ringfd, &e))\n      goto fail;\n  }\n\n  iou->sqhead = (uint32_t*) (sq + params.sq_off.head);\n  iou->sqtail = (uint32_t*) (sq + params.sq_off.tail);\n  iou->sqmask = *(uint32_t*) (sq + params.sq_off.ring_mask);\n  iou->sqarray = (uint32_t*) (sq + params.sq_off.array);\n  iou->sqflags = (uint32_t*) (sq + params.sq_off.flags);\n  iou->cqhead = (uint32_t*) (sq + params.cq_off.head);\n  iou->cqtail = (uint32_t*) (sq + params.cq_off.tail);\n  iou->cqmask = *(uint32_t*) (sq + params.cq_off.ring_mask);\n  iou->sq = sq;\n  iou->cqe = sq + params.cq_off.cqes;\n  iou->sqe = sqe;\n  iou->sqlen = sqlen;\n  iou->cqlen = cqlen;\n  iou->maxlen = maxlen;\n  iou->sqelen = sqelen;\n  iou->ringfd = ringfd;\n  iou->in_flight = 0;\n  iou->flags = 0;\n\n  if (uv__kernel_version() >= /* 5.15.0 */ 0x050F00)\n    iou->flags |= UV__MKDIRAT_SYMLINKAT_LINKAT;\n\n  for (i = 0; i <= iou->sqmask; i++)\n    iou->sqarray[i] = i;  /* Slot -> sqe identity mapping. */\n\n  return;\n\nfail:\n  if (sq != MAP_FAILED)\n    munmap(sq, maxlen);\n\n  if (sqe != MAP_FAILED)\n    munmap(sqe, sqelen);\n\n  uv__close(ringfd);\n}\n"
                    }
                }
            ]
        }
    },
    {
        "subtask": "\"打印与句柄相关的操作并输出独特队列项用于调试或监控的函数是什么？\"",
        "results": {
            "query": "实现初始化和管理I/O事件队列、处理文件描述符事件及维护相关指针的函数是什么？",
            "results": [
                {
                    "similarity": 0.5643660685797899,
                    "meta_info": {
                        "category": "Function",
                        "code": "static int uv__pipe_write_data(uv_loop_t* loop,\n                               uv_write_t* req,\n                               uv_pipe_t* handle,\n                               const uv_buf_t bufs[],\n                               size_t nbufs,\n                               uv_write_cb cb,\n                               int copy_always) {\n  int err;\n  int result;\n  uv_buf_t write_buf;\n\n  assert(handle->handle != INVALID_HANDLE_VALUE);\n\n  UV_REQ_INIT(req, UV_WRITE);\n  req->handle = (uv_stream_t*) handle;\n  req->send_handle = NULL;\n  req->cb = cb;\n  /* Private fields. */\n  req->coalesced = 0;\n  req->event_handle = NULL;\n  req->wait_handle = INVALID_HANDLE_VALUE;\n\n  /* Prepare the overlapped structure. */\n  memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));\n  if (handle->flags & (UV_HANDLE_EMULATE_IOCP | UV_HANDLE_BLOCKING_WRITES)) {\n    req->event_handle = CreateEvent(NULL, 0, 0, NULL);\n    if (req->event_handle == NULL) {\n      uv_fatal_error(GetLastError(), \"CreateEvent\");\n    }\n    req->u.io.overlapped.hEvent = (HANDLE) ((uintptr_t) req->event_handle | 1);\n  }\n  req->write_buffer = uv_null_buf_;\n\n  if (nbufs == 0) {\n    /* Write empty buffer. */\n    write_buf = uv_null_buf_;\n  } else if (nbufs == 1 && !copy_always) {\n    /* Write directly from bufs[0]. */\n    write_buf = bufs[0];\n  } else {\n    /* Coalesce all `bufs` into one big buffer. This also creates a new\n     * write-request structure that replaces the old one. */\n    err = uv__build_coalesced_write_req(req, bufs, nbufs, &req, &write_buf);\n    if (err != 0)\n      return err;\n  }\n\n  if ((handle->flags &\n      (UV_HANDLE_BLOCKING_WRITES | UV_HANDLE_NON_OVERLAPPED_PIPE)) ==\n      (UV_HANDLE_BLOCKING_WRITES | UV_HANDLE_NON_OVERLAPPED_PIPE)) {\n    DWORD bytes;\n    result =\n        WriteFile(handle->handle, write_buf.base, write_buf.len, &bytes, NULL);\n\n    if (!result) {\n      err = GetLastError();\n      return err;\n    } else {\n      /* Request completed immediately. */\n      req->u.io.queued_bytes = 0;\n    }\n\n    REGISTER_HANDLE_REQ(loop, handle, req);\n    handle->reqs_pending++;\n    handle->stream.conn.write_reqs_pending++;\n    POST_COMPLETION_FOR_REQ(loop, req);\n    return 0;\n  } else if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {\n    req->write_buffer = write_buf;\n    uv__insert_non_overlapped_write_req(handle, req);\n    if (handle->stream.conn.write_reqs_pending == 0) {\n      uv__queue_non_overlapped_write(handle);\n    }\n\n    /* Request queued by the kernel. */\n    req->u.io.queued_bytes = write_buf.len;\n    handle->write_queue_size += req->u.io.queued_bytes;\n  } else if (handle->flags & UV_HANDLE_BLOCKING_WRITES) {\n    /* Using overlapped IO, but wait for completion before returning */\n    result = WriteFile(handle->handle,\n                       write_buf.base,\n                       write_buf.len,\n                       NULL,\n                       &req->u.io.overlapped);\n\n    if (!result && GetLastError() != ERROR_IO_PENDING) {\n      err = GetLastError();\n      CloseHandle(req->event_handle);\n      req->event_handle = NULL;\n      return err;\n    }\n\n    if (result) {\n      /* Request completed immediately. */\n      req->u.io.queued_bytes = 0;\n    } else {\n      /* Request queued by the kernel. */\n      req->u.io.queued_bytes = write_buf.len;\n      handle->write_queue_size += req->u.io.queued_bytes;\n      if (WaitForSingleObject(req->event_handle, INFINITE) !=\n          WAIT_OBJECT_0) {\n        err = GetLastError();\n        CloseHandle(req->event_handle);\n        req->event_handle = NULL;\n        return err;\n      }\n    }\n    CloseHandle(req->event_handle);\n    req->event_handle = NULL;\n\n    REGISTER_HANDLE_REQ(loop, handle, req);\n    handle->reqs_pending++;\n    handle->stream.conn.write_reqs_pending++;\n    return 0;\n  } else {\n    result = WriteFile(handle->handle,\n                       write_buf.base,\n                       write_buf.len,\n                       NULL,\n                       &req->u.io.overlapped);\n\n    if (!result && GetLastError() != ERROR_IO_PENDING) {\n      return GetLastError();\n    }\n\n    if (result) {\n      /* Request completed immediately. */\n      req->u.io.queued_bytes = 0;\n    } else {\n      /* Request queued by the kernel. */\n      req->u.io.queued_bytes = write_buf.len;\n      handle->write_queue_size += req->u.io.queued_bytes;\n    }\n\n    if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n      if (!RegisterWaitForSingleObject(&req->wait_handle,\n          req->event_handle, post_completion_write_wait, (void*) req,\n          INFINITE, WT_EXECUTEINWAITTHREAD)) {\n        return GetLastError();\n      }\n    }\n  }\n\n  REGISTER_HANDLE_REQ(loop, handle, req);\n  handle->reqs_pending++;\n  handle->stream.conn.write_reqs_pending++;\n\n  return 0;\n}\n"
                    }
                },
                {
                    "similarity": 0.5580167437781854,
                    "meta_info": {
                        "category": "Function",
                        "code": "int uv__pipe_write_ipc(uv_loop_t* loop,\n                       uv_write_t* req,\n                       uv_pipe_t* handle,\n                       const uv_buf_t data_bufs[],\n                       size_t data_buf_count,\n                       uv_stream_t* send_handle,\n                       uv_write_cb cb) {\n  uv_buf_t stack_bufs[6];\n  uv_buf_t* bufs;\n  size_t buf_count, buf_index;\n  uv__ipc_frame_header_t frame_header;\n  uv__ipc_socket_xfer_type_t xfer_type = UV__IPC_SOCKET_XFER_NONE;\n  uv__ipc_socket_xfer_info_t xfer_info;\n  uint64_t data_length;\n  size_t i;\n  int err;\n\n  /* Compute the combined size of data buffers. */\n  data_length = 0;\n  for (i = 0; i < data_buf_count; i++)\n    data_length += data_bufs[i].len;\n  if (data_length > UINT32_MAX)\n    return WSAENOBUFS; /* Maps to UV_ENOBUFS. */\n\n  /* Prepare the frame's socket xfer payload. */\n  if (send_handle != NULL) {\n    uv_tcp_t* send_tcp_handle = (uv_tcp_t*) send_handle;\n\n    /* Verify that `send_handle` it is indeed a tcp handle. */\n    if (send_tcp_handle->type != UV_TCP)\n      return ERROR_NOT_SUPPORTED;\n\n    /* Export the tcp handle. */\n    err = uv__tcp_xfer_export(send_tcp_handle,\n                              uv__pipe_get_ipc_remote_pid(handle),\n                              &xfer_type,\n                              &xfer_info);\n    if (err != 0)\n      return err;\n  }\n\n  /* Compute the number of uv_buf_t's required. */\n  buf_count = 1 + data_buf_count; /* Frame header and data buffers. */\n  if (send_handle != NULL)\n    buf_count += 1; /* One extra for the socket xfer information. */\n\n  /* Use the on-stack buffer array if it is big enough; otherwise allocate\n   * space for it on the heap. */\n  if (buf_count < ARRAY_SIZE(stack_bufs)) {\n    /* Use on-stack buffer array. */\n    bufs = stack_bufs;\n  } else {\n    /* Use heap-allocated buffer array. */\n    bufs = uv__calloc(buf_count, sizeof(uv_buf_t));\n    if (bufs == NULL)\n      return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */\n  }\n  buf_index = 0;\n\n  /* Initialize frame header and add it to the buffers list. */\n  memset(&frame_header, 0, sizeof frame_header);\n  bufs[buf_index++] = uv_buf_init((char*) &frame_header, sizeof frame_header);\n\n  if (send_handle != NULL) {\n    /* Add frame header flags. */\n    switch (xfer_type) {\n      case UV__IPC_SOCKET_XFER_TCP_CONNECTION:\n        frame_header.flags |= UV__IPC_FRAME_HAS_SOCKET_XFER |\n                              UV__IPC_FRAME_XFER_IS_TCP_CONNECTION;\n        break;\n      case UV__IPC_SOCKET_XFER_TCP_SERVER:\n        frame_header.flags |= UV__IPC_FRAME_HAS_SOCKET_XFER;\n        break;\n      default:\n        assert(0);  /* Unreachable. */\n    }\n    /* Add xfer info buffer. */\n    bufs[buf_index++] = uv_buf_init((char*) &xfer_info, sizeof xfer_info);\n  }\n\n  if (data_length > 0) {\n    /* Update frame header. */\n    frame_header.flags |= UV__IPC_FRAME_HAS_DATA;\n    frame_header.data_length = (uint32_t) data_length;\n    /* Add data buffers to buffers list. */\n    for (i = 0; i < data_buf_count; i++)\n      bufs[buf_index++] = data_bufs[i];\n  }\n\n  /* Write buffers. We set the `always_copy` flag, so it is not a problem that\n   * some of the written data lives on the stack. */\n  err = uv__pipe_write_data(loop, req, handle, bufs, buf_count, cb, 1);\n\n  /* If we had to heap-allocate the bufs array, free it now. */\n  if (bufs != stack_bufs) {\n    uv__free(bufs);\n  }\n\n  return err;\n}\n"
                    }
                },
                {
                    "similarity": 0.5544514325588098,
                    "meta_info": {
                        "category": "Function",
                        "code": "static void fs__create_junction(uv_fs_t* req, const WCHAR* path,\n    const WCHAR* new_path) {\n  HANDLE handle = INVALID_HANDLE_VALUE;\n  REPARSE_DATA_BUFFER *buffer = NULL;\n  int created = 0;\n  int target_len;\n  int is_absolute, is_long_path;\n  int needed_buf_size, used_buf_size, used_data_size, path_buf_len;\n  int start, len, i;\n  int add_slash;\n  DWORD bytes;\n  WCHAR* path_buf;\n\n  target_len = wcslen(path);\n  is_long_path = wcsncmp(path, LONG_PATH_PREFIX, LONG_PATH_PREFIX_LEN) == 0;\n\n  if (is_long_path) {\n    is_absolute = 1;\n  } else {\n    is_absolute = target_len >= 3 && IS_LETTER(path[0]) &&\n      path[1] == L':' && IS_SLASH(path[2]);\n  }\n\n  if (!is_absolute) {\n    /* Not supporting relative paths */\n    SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_NOT_SUPPORTED);\n    return;\n  }\n\n  /* Do a pessimistic calculation of the required buffer size */\n  needed_buf_size =\n      FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) +\n      JUNCTION_PREFIX_LEN * sizeof(WCHAR) +\n      2 * (target_len + 2) * sizeof(WCHAR);\n\n  /* Allocate the buffer */\n  buffer = (REPARSE_DATA_BUFFER*)uv__malloc(needed_buf_size);\n  if (!buffer) {\n    uv_fatal_error(ERROR_OUTOFMEMORY, \"uv__malloc\");\n  }\n\n  /* Grab a pointer to the part of the buffer where filenames go */\n  path_buf = (WCHAR*)&(buffer->MountPointReparseBuffer.PathBuffer);\n  path_buf_len = 0;\n\n  /* Copy the substitute (internal) target path */\n  start = path_buf_len;\n\n  wcsncpy((WCHAR*)&path_buf[path_buf_len], JUNCTION_PREFIX,\n    JUNCTION_PREFIX_LEN);\n  path_buf_len += JUNCTION_PREFIX_LEN;\n\n  add_slash = 0;\n  for (i = is_long_path ? LONG_PATH_PREFIX_LEN : 0; path[i] != L'\\0'; i++) {\n    if (IS_SLASH(path[i])) {\n      add_slash = 1;\n      continue;\n    }\n\n    if (add_slash) {\n      path_buf[path_buf_len++] = L'\\\\';\n      add_slash = 0;\n    }\n\n    path_buf[path_buf_len++] = path[i];\n  }\n  path_buf[path_buf_len++] = L'\\\\';\n  len = path_buf_len - start;\n\n  /* Set the info about the substitute name */\n  buffer->MountPointReparseBuffer.SubstituteNameOffset = start * sizeof(WCHAR);\n  buffer->MountPointReparseBuffer.SubstituteNameLength = len * sizeof(WCHAR);\n\n  /* Insert null terminator */\n  path_buf[path_buf_len++] = L'\\0';\n\n  /* Copy the print name of the target path */\n  start = path_buf_len;\n  add_slash = 0;\n  for (i = is_long_path ? LONG_PATH_PREFIX_LEN : 0; path[i] != L'\\0'; i++) {\n    if (IS_SLASH(path[i])) {\n      add_slash = 1;\n      continue;\n    }\n\n    if (add_slash) {\n      path_buf[path_buf_len++] = L'\\\\';\n      add_slash = 0;\n    }\n\n    path_buf[path_buf_len++] = path[i];\n  }\n  len = path_buf_len - start;\n  if (len == 2) {\n    path_buf[path_buf_len++] = L'\\\\';\n    len++;\n  }\n\n  /* Set the info about the print name */\n  buffer->MountPointReparseBuffer.PrintNameOffset = start * sizeof(WCHAR);\n  buffer->MountPointReparseBuffer.PrintNameLength = len * sizeof(WCHAR);\n\n  /* Insert another null terminator */\n  path_buf[path_buf_len++] = L'\\0';\n\n  /* Calculate how much buffer space was actually used */\n  used_buf_size = FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) +\n    path_buf_len * sizeof(WCHAR);\n  used_data_size = used_buf_size -\n    FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer);\n\n  /* Put general info in the data buffer */\n  buffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n  buffer->ReparseDataLength = used_data_size;\n  buffer->Reserved = 0;\n\n  /* Create a new directory */\n  if (!CreateDirectoryW(new_path, NULL)) {\n    SET_REQ_WIN32_ERROR(req, GetLastError());\n    goto error;\n  }\n  created = 1;\n\n  /* Open the directory */\n  handle = CreateFileW(new_path,\n                       GENERIC_WRITE,\n                       0,\n                       NULL,\n                       OPEN_EXISTING,\n                       FILE_FLAG_BACKUP_SEMANTICS |\n                         FILE_FLAG_OPEN_REPARSE_POINT,\n                       NULL);\n  if (handle == INVALID_HANDLE_VALUE) {\n    SET_REQ_WIN32_ERROR(req, GetLastError());\n    goto error;\n  }\n\n  /* Create the actual reparse point */\n  if (!DeviceIoControl(handle,\n                       FSCTL_SET_REPARSE_POINT,\n                       buffer,\n                       used_buf_size,\n                       NULL,\n                       0,\n                       &bytes,\n                       NULL)) {\n    SET_REQ_WIN32_ERROR(req, GetLastError());\n    goto error;\n  }\n\n  /* Clean up */\n  CloseHandle(handle);\n  uv__free(buffer);\n\n  SET_REQ_RESULT(req, 0);\n  return;\n\nerror:\n  uv__free(buffer);\n\n  if (handle != INVALID_HANDLE_VALUE) {\n    CloseHandle(handle);\n  }\n\n  if (created) {\n    RemoveDirectoryW(new_path);\n  }\n}\n"
                    }
                },
                {
                    "similarity": 0.55231886478438,
                    "meta_info": {
                        "category": "Function",
                        "code": "INLINE static int fs__readlink_handle(HANDLE handle,\n                                      char** target_ptr,\n                                      size_t* target_len_ptr) {\n  char buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n  REPARSE_DATA_BUFFER* reparse_data = (REPARSE_DATA_BUFFER*) buffer;\n  WCHAR* w_target;\n  DWORD w_target_len;\n  DWORD bytes;\n  size_t i;\n  size_t len;\n\n  if (!DeviceIoControl(handle,\n                       FSCTL_GET_REPARSE_POINT,\n                       NULL,\n                       0,\n                       buffer,\n                       sizeof buffer,\n                       &bytes,\n                       NULL)) {\n    return -1;\n  }\n\n  if (reparse_data->ReparseTag == IO_REPARSE_TAG_SYMLINK) {\n    /* Real symlink */\n    w_target = reparse_data->SymbolicLinkReparseBuffer.PathBuffer +\n        (reparse_data->SymbolicLinkReparseBuffer.SubstituteNameOffset /\n        sizeof(WCHAR));\n    w_target_len =\n        reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength /\n        sizeof(WCHAR);\n\n    /* Real symlinks can contain pretty much everything, but the only thing we\n     * really care about is undoing the implicit conversion to an NT namespaced\n     * path that CreateSymbolicLink will perform on absolute paths. If the path\n     * is win32-namespaced then the user must have explicitly made it so, and\n     * we better just return the unmodified reparse data. */\n    if (w_target_len >= 4 &&\n        w_target[0] == L'\\\\' &&\n        w_target[1] == L'?' &&\n        w_target[2] == L'?' &&\n        w_target[3] == L'\\\\') {\n      /* Starts with \\??\\ */\n      if (w_target_len >= 6 &&\n          ((w_target[4] >= L'A' && w_target[4] <= L'Z') ||\n           (w_target[4] >= L'a' && w_target[4] <= L'z')) &&\n          w_target[5] == L':' &&\n          (w_target_len == 6 || w_target[6] == L'\\\\')) {\n        /* \\??\\<drive>:\\ */\n        w_target += 4;\n        w_target_len -= 4;\n\n      } else if (w_target_len >= 8 &&\n                 (w_target[4] == L'U' || w_target[4] == L'u') &&\n                 (w_target[5] == L'N' || w_target[5] == L'n') &&\n                 (w_target[6] == L'C' || w_target[6] == L'c') &&\n                 w_target[7] == L'\\\\') {\n        /* \\??\\UNC\\<server>\\<share>\\ - make sure the final path looks like\n         * \\\\<server>\\<share>\\ */\n        w_target += 6;\n        w_target[0] = L'\\\\';\n        w_target_len -= 6;\n      }\n    }\n\n  } else if (reparse_data->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {\n    /* Junction. */\n    w_target = reparse_data->MountPointReparseBuffer.PathBuffer +\n        (reparse_data->MountPointReparseBuffer.SubstituteNameOffset /\n        sizeof(WCHAR));\n    w_target_len = reparse_data->MountPointReparseBuffer.SubstituteNameLength /\n        sizeof(WCHAR);\n\n    /* Only treat junctions that look like \\??\\<drive>:\\ as symlink. Junctions\n     * can also be used as mount points, like \\??\\Volume{<guid>}, but that's\n     * confusing for programs since they wouldn't be able to actually\n     * understand such a path when returned by uv_readlink(). UNC paths are\n     * never valid for junctions so we don't care about them. */\n    if (!(w_target_len >= 6 &&\n          w_target[0] == L'\\\\' &&\n          w_target[1] == L'?' &&\n          w_target[2] == L'?' &&\n          w_target[3] == L'\\\\' &&\n          ((w_target[4] >= L'A' && w_target[4] <= L'Z') ||\n           (w_target[4] >= L'a' && w_target[4] <= L'z')) &&\n          w_target[5] == L':' &&\n          (w_target_len == 6 || w_target[6] == L'\\\\'))) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n\n    /* Remove leading \\??\\ */\n    w_target += 4;\n    w_target_len -= 4;\n\n  } else if (reparse_data->ReparseTag == IO_REPARSE_TAG_APPEXECLINK) {\n    /* String #3 in the list has the target filename. */\n    if (reparse_data->AppExecLinkReparseBuffer.StringCount < 3) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n    w_target = reparse_data->AppExecLinkReparseBuffer.StringList;\n    /* The StringList buffer contains a list of strings separated by \"\\0\",   */\n    /* with \"\\0\\0\" terminating the list. Move to the 3rd string in the list: */\n    for (i = 0; i < 2; ++i) {\n      len = wcslen(w_target);\n      if (len == 0) {\n        SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n        return -1;\n      }\n      w_target += len + 1;\n    }\n    w_target_len = wcslen(w_target);\n    if (w_target_len == 0) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n    /* Make sure it is an absolute path. */\n    if (!(w_target_len >= 3 &&\n         ((w_target[0] >= L'a' && w_target[0] <= L'z') ||\n          (w_target[0] >= L'A' && w_target[0] <= L'Z')) &&\n         w_target[1] == L':' &&\n         w_target[2] == L'\\\\')) {\n      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n      return -1;\n    }\n\n  } else {\n    /* Reparse tag does not indicate a symlink. */\n    SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);\n    return -1;\n  }\n\n  assert(target_ptr == NULL || *target_ptr == NULL);\n  return uv_utf16_to_wtf8(w_target, w_target_len, target_ptr, target_len_ptr);\n}\n"
                    }
                },
                {
                    "similarity": 0.5515046119689941,
                    "meta_info": {
                        "category": "Function",
                        "code": "static void uv__iou_init(int epollfd,\n                         struct uv__iou* iou,\n                         uint32_t entries,\n                         uint32_t flags) {\n  struct uv__io_uring_params params;\n  struct epoll_event e;\n  size_t cqlen;\n  size_t sqlen;\n  size_t maxlen;\n  size_t sqelen;\n  uint32_t i;\n  char* sq;\n  char* sqe;\n  int ringfd;\n\n  sq = MAP_FAILED;\n  sqe = MAP_FAILED;\n\n  if (!uv__use_io_uring())\n    return;\n\n  /* SQPOLL required CAP_SYS_NICE until linux v5.12 relaxed that requirement.\n   * Mostly academic because we check for a v5.13 kernel afterwards anyway.\n   */\n  memset(&params, 0, sizeof(params));\n  params.flags = flags;\n\n  if (flags & UV__IORING_SETUP_SQPOLL)\n    params.sq_thread_idle = 10;  /* milliseconds */\n\n  /* Kernel returns a file descriptor with O_CLOEXEC flag set. */\n  ringfd = uv__io_uring_setup(entries, &params);\n  if (ringfd == -1)\n    return;\n\n  /* IORING_FEAT_RSRC_TAGS is used to detect linux v5.13 but what we're\n   * actually detecting is whether IORING_OP_STATX works with SQPOLL.\n   */\n  if (!(params.features & UV__IORING_FEAT_RSRC_TAGS))\n    goto fail;\n\n  /* Implied by IORING_FEAT_RSRC_TAGS but checked explicitly anyway. */\n  if (!(params.features & UV__IORING_FEAT_SINGLE_MMAP))\n    goto fail;\n\n  /* Implied by IORING_FEAT_RSRC_TAGS but checked explicitly anyway. */\n  if (!(params.features & UV__IORING_FEAT_NODROP))\n    goto fail;\n\n  sqlen = params.sq_off.array + params.sq_entries * sizeof(uint32_t);\n  cqlen =\n      params.cq_off.cqes + params.cq_entries * sizeof(struct uv__io_uring_cqe);\n  maxlen = sqlen < cqlen ? cqlen : sqlen;\n  sqelen = params.sq_entries * sizeof(struct uv__io_uring_sqe);\n\n  sq = mmap(0,\n            maxlen,\n            PROT_READ | PROT_WRITE,\n            MAP_SHARED | MAP_POPULATE,\n            ringfd,\n            0);  /* IORING_OFF_SQ_RING */\n\n  sqe = mmap(0,\n             sqelen,\n             PROT_READ | PROT_WRITE,\n             MAP_SHARED | MAP_POPULATE,\n             ringfd,\n             0x10000000ull);  /* IORING_OFF_SQES */\n\n  if (sq == MAP_FAILED || sqe == MAP_FAILED)\n    goto fail;\n\n  if (flags & UV__IORING_SETUP_SQPOLL) {\n    /* Only interested in completion events. To get notified when\n     * the kernel pulls items from the submission ring, add POLLOUT.\n     */\n    memset(&e, 0, sizeof(e));\n    e.events = POLLIN;\n    e.data.fd = ringfd;\n\n    if (uv__epoll_ctl(epollfd, EPOLL_CTL_ADD, ringfd, &e))\n      goto fail;\n  }\n\n  iou->sqhead = (uint32_t*) (sq + params.sq_off.head);\n  iou->sqtail = (uint32_t*) (sq + params.sq_off.tail);\n  iou->sqmask = *(uint32_t*) (sq + params.sq_off.ring_mask);\n  iou->sqarray = (uint32_t*) (sq + params.sq_off.array);\n  iou->sqflags = (uint32_t*) (sq + params.sq_off.flags);\n  iou->cqhead = (uint32_t*) (sq + params.cq_off.head);\n  iou->cqtail = (uint32_t*) (sq + params.cq_off.tail);\n  iou->cqmask = *(uint32_t*) (sq + params.cq_off.ring_mask);\n  iou->sq = sq;\n  iou->cqe = sq + params.cq_off.cqes;\n  iou->sqe = sqe;\n  iou->sqlen = sqlen;\n  iou->cqlen = cqlen;\n  iou->maxlen = maxlen;\n  iou->sqelen = sqelen;\n  iou->ringfd = ringfd;\n  iou->in_flight = 0;\n  iou->flags = 0;\n\n  if (uv__kernel_version() >= /* 5.15.0 */ 0x050F00)\n    iou->flags |= UV__MKDIRAT_SYMLINKAT_LINKAT;\n\n  for (i = 0; i <= iou->sqmask; i++)\n    iou->sqarray[i] = i;  /* Slot -> sqe identity mapping. */\n\n  return;\n\nfail:\n  if (sq != MAP_FAILED)\n    munmap(sq, maxlen);\n\n  if (sqe != MAP_FAILED)\n    munmap(sqe, sqelen);\n\n  uv__close(ringfd);\n}\n"
                    }
                }
            ]
        }
    }
]